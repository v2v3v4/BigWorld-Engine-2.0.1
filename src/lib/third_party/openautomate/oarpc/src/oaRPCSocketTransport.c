/*******************************************************************************
 * NVIDIA Corporation 
 * Software License Agreement - OpenAutomate SDK 
 * 
 * IMPORTANT - READ BEFORE COPYING, INSTALLING OR USING
 * Do not use or load the OpenAutomate SDK and any associated materials
 * provided by NVIDIA on NVIDIA’s website (collectively, the "Software")
 * until You have carefully read the following terms and conditions. By
 * loading or using the Software, You agree to fully comply with the terms
 * and conditions of this Software License Agreement ("Agreement") by and
 * between NVIDIA Corporation, a Delaware corporation with its principal
 * place of business at 2701 San Tomas Expressway, Santa Clara, California
 * 95050 U.S.A. ("NVIDIA"), and You. If You do not wish to so agree, do not
 * install or use the Software. 
 * 
 * For the purposes of this Agreement: 
 * 
 * "Licensee," "You" and/or "Your" shall mean, collectively and
 * individually, Original Equipment Manufacturers, Independent Hardware
 * Vendors, Independent Software Vendors, and End-Users of the Software
 * pursuant to the terms and conditions of this Agreement.   
 * 
 * "Derivative Works" shall mean derivatives of the Software created by You
 * or a third party on Your behalf, which term shall include:  (a) for
 * copyrightable or copyrighted material, any translation, abridgement,
 * revision or other form in which an existing work may be recast,
 * transformed or adapted; (b) for work protected by topography or mask
 * right, any translation, abridgement, revision or other form in which an
 * existing work may be recast, transformed or adapted; (c) for patentable
 * or patented material, any Improvement; and (d) for material protected by
 * trade secret, any new material derived from or employing such existing
 * trade secret.
 * 
 * "Excluded License" is any license that requires as a condition of use,
 * modification and/or distribution of software subject to the Excluded
 * License, that such software or other software distributed and/or
 * combined with such software be (i) disclosed or distributed in source
 * code form, (ii) licensed for the purpose of making derivative works, or
 * (iii) redistributable at no charge.
 * 
 * SECTION 1 - GRANT OF LICENSE.
 * NVIDIA agrees to provide the Software and any associated materials
 * pursuant to the terms and conditions of this Agreement.  Subject to the
 * terms of this Agreement, NVIDIA grants to You a nonexclusive,
 * transferable, worldwide, revocable, limited, royalty-free, fully paid-up
 * license under NVIDIA’s copyrights to 
 * 
 * (a) install, deploy, use, have used execute, reproduce, display,
 * perform, run, modify the source code of the Software, or to prepare and
 * have prepared Derivative Works thereof the Software for Your own
 * internal development, testing and maintenance purposes to incorporate
 * the Software or Derivative Works thereof, in part or whole, into Your
 * software applications; 
 * 
 * (b)	 to transfer, distribute and sublicense the Software (in its
 * unmodified form as delivered to You by NVIDIA pursuant to this
 * Agreement) in any medium or technology for Your sublicensees to
 * incorporate the Software or Derivative Works thereof, in part or whole,
 * into their respective software applications; and
 * 
 * (c) to transfer, distribute and sublicense Derivative Works (in object
 * code only) of the Software (i)_as incorporated in Your application
 * software in any medium or technology; and (ii) certified as OpenAutomate
 * Compatible Software.
 * 
 * You may exercise your license rights pursuant to Subsection 1(b) and (c)
 * above pursuant to the terms and conditions of any form of end-user
 * software license agreement of Your choice, including but not limited to
 * an Excluded License.
 * 
 * In the event NVIDIA certifies Your application software, incorporating
 * the Derivative Works (in object code only) of the Software, as
 * OpenAutomate compatible ("OpenAutomate Compatible Software"), NVIDIA
 * grants You a nonexclusive, worldwide, revocable, paid-up license to use
 * the name and trademark to "OpenAutomate Compatible" solely for the
 * purposes of identifying and/or marketing Your application software as
 * OpenAutomate Compatible Software; provided that Licensee fully complies
 * with the following:	
 * 
 * (x) Licensee agrees that it is strictly prohibited from using the name
 * and trademark of "OpenAutomate Compatible" if Your application software
 * is not OpenAutomate Compatible Software;
 * 
 * (y) if NVIDIA objects to Your improper use of the "OpenAutomate
 * Compatible" name and trademark, You will take all reasonable steps
 * necessary to resolve NVIDIA’s objections. NVIDIA may reasonably monitor
 * the quality of Your application software bearing the "OpenAutomate
 * Compatible" name or trademark pursuant to this Agreement; and
 * 
 * (z) any goodwill attached to NVIDIA’s trademarks, service marks, or
 * trade names belong to NVIDIA and this Agreement does not grant You any
 * right to use them.
 * 
 * If You are not the final manufacturer or vendor of a computer system or
 * software program incorporating the Software, or if Your Contractors (as
 * defined below), affiliates or subsidiaries need to exercise any, some or
 * all of the license grant described above herein to the Software on Your
 * behalf, then You may transfer a copy of the Software, (and related
 * end-user documentation) to such recipient for use in accordance with the
 * terms of this Agreement, provided such recipient agrees to be fully
 * bound by the terms hereof. Except as expressly permitted in this
 * Agreement, Unless otherwise authorized in the Agreement, You shall not
 * otherwise assign, sublicense, lease, or in any other way transfer or
 * disclose Software to any third party. Unless otherwise authorized in the
 * Agreement, You shall not reverse- compile, disassemble,
 * reverse-engineer, or in any manner attempt to derive the source code of
 * the Software from the object code portions of the Software. 
 * 
 * Except as expressly stated in this Agreement, no license or right is
 * granted to You directly or by implication, inducement, estoppel or
 * otherwise. NVIDIA shall have the right to inspect or have an independent
 * auditor inspect Your relevant records to verify Your compliance with the
 * terms and conditions of this Agreement. 
 * 
 * SECTION 2 - CONFIDENTIALITY.
 * If applicable, any exchange of Confidential Information (as defined in
 * the NDA) shall be made pursuant to the terms and conditions of a
 * separately signed Non-Disclosure Agreement ("NDA") by and between NVIDIA
 * and You. For the sake of clarity, You agree that the Software is
 * Confidential Information of NVIDIA.
 * 
 * If You wish to have a third party consultant or subcontractor
 * ("Contractor") perform work on Your behalf which involves access to or
 * use of Software, You shall obtain a written confidentiality agreement
 * from the Contractor which contains terms and obligations with respect to
 * access to or use of Software no less restrictive than those set forth in
 * this Agreement and excluding any distribution or sublicense rights, and
 * use for any other purpose than permitted in this Agreement. Otherwise,
 * You shall not disclose the terms or existence of this Agreement or use
 * NVIDIA's name in any publications, advertisements, or other
 * announcements without NVIDIA's prior written consent.  Unless otherwise
 * provided in this Agreement, You do not have any rights to use any NVIDIA
 * trademarks or logos.
 * 
 * SECTION 3 - OWNERSHIP OF SOFTWARE AND INTELLECTUAL PROPERTY RIGHTS.
 * All rights, title and interest to all copies of the Software remain with
 * NVIDIA, subsidiaries, licensors, or its suppliers. The Software is
 * copyrighted and protected by the laws of the United States and other
 * countries, and international treaty provisions. You may not remove any
 * copyright notices from the Software. NVIDIA may make changes to the
 * Software, or to items referenced therein, at any time and without
 * notice, but is not obligated to support or update the Software. Except
 * as otherwise expressly provided, NVIDIA grants no express or implied
 * right under any NVIDIA patents, copyrights, trademarks, or other
 * intellectual property rights. 
 * 
 * All rights, title and interest in the Derivative Works of the Software
 * remain with You subject to the underlying license from NVIDIA to the
 * Software.  In Your sole discretion, You may grant NVIDIA, upon NVIDIA’s
 * request for such a license described herein, an irrevocable, perpetual,
 * nonexclusive, worldwide, royalty-free paid-up license to make, have
 * made, use, have used, sell, license, distribute, sublicense or otherwise
 * transfer Derivative Works created by You that add functionality or
 * improvement to the Software.  
 * 
 * You has no obligation to give NVIDIA any suggestions, comments or other
 * feedback ("Feedback") relating to the Software.  However, NVIDIA may use
 * and include any Feedback that You voluntarily provide to improve the
 * Software or other related NVIDIA technologies.  Accordingly, if You
 * provide Feedback, You agree NVIDIA and its licensees may freely use,
 * reproduce, license, distribute, and otherwise commercialize the Feedback
 * in the Software or other related technologies without the payment of any
 * royalties or fees.  
 * 
 * You may transfer the Software only if the recipient agrees to be fully
 * bound by these terms and conditions of this Agreement. 
 * 
 * SECTION 4 - NO WARRANTIES. 
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY
 * OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT,
 * OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA does not warrant or assume
 * responsibility for the accuracy or completeness of any information,
 * text, graphics, links or other items contained within the Software.
 * NVIDIA does not represent that errors or other defects will be
 * identified or corrected.
 * 
 * SECTION 5 - LIMITATION OF LIABILITY.
 * EXCEPT WITH RESPECT TO THE MISUSE OF THE OTHER PARTY’S INTELLECTUAL
 * PROPERTY OR DISCLOSURE OF THE OTHER PARTY’S CONFIDENTIAL INFORMATION IN
 * BREACH OF THIS AGREEMENT, IN NO EVENT SHALL NVIDIA, SUBSIDIARIES,
 * LICENSORS, OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION,  INDIRECT, LOST PROFITS, CONSEQUENTIAL,
 * BUSINESS INTERRUPTION OR LOST INFORMATION) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THE SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS PROHIBIT EXCLUSION OR
 * LIMITATION OF LIABILITY FOR IMPLIED WARRANTIES OR CONSEQUENTIAL OR
 * INCIDENTAL DAMAGES, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU. YOU
 * MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM JURISDICTION TO
 * JURISDICTION.  NOTWITHSTANDING THE FOREGOING, NVIDIA’S AGGREGATE
 * LIABILITY ARISING OUT OF THIS AGREEMENT SHALL NOT EXCEED ONE HUNDRED
 * UNITED STATES DOLLARS (USD$100).
 * 
 * SECTION 6 - TERM.
 * This Agreement and the licenses granted hereunder shall be effective as
 * of the date You download the applicable Software ("Effective Date") and
 * continue for a period of one (1) year ("Initial Term") respectively,
 * unless terminated earlier in accordance with the "Termination" provision
 * of this Agreement.  Unless either party notifies the other party of its
 * intent to terminate this Agreement at least three (3) months prior to
 * the end of the Initial Term or the applicable renewal period, this
 * Agreement will be automatically renewed for one (1) year renewal periods
 * thereafter, unless terminated in accordance with the "Termination"
 * provision of this Agreement.  
 * 
 * SECTION 7 - TERMINATION.
 * NVIDIA may terminate this Agreement at any time if You violate its
 * terms. Upon termination, You will immediately destroy the Software or
 * return all copies of the Software to NVIDIA, and certify to NVIDIA in
 * writing that such actions have been completed.  Upon termination or
 * expiration of this Agreement the license grants to Licensee shall
 * terminate, except that sublicenses rightfully granted by Licensee under
 * this Agreement in connection with Section 1(b) and (c) of this Agreement
 * provided by Licensee prior to the termination or expiration of this
 * Agreement shall survive in accordance with their respective form of
 * license terms and conditions.
 * 
 * SECTION 8 - MISCELLANEOUS.
 * 
 * SECTION 8.1 - SURVIVAL.
 * Those provisions in this Agreement, which by their nature need to
 * survive the termination or expiration of this Agreement, shall survive
 * termination or expiration of the Agreement, including but not limited to
 * Sections 2, 3, 4, 5, 7, and 8.
 * 
 * SECTION 8.2 - APPLICABLE LAWS.
 * Claims arising under this Agreement shall be governed by the laws of
 * Delaware, excluding its principles of conflict of laws and the United
 * Nations Convention on Contracts for the Sale of Goods. The state and/or
 * federal courts residing in Santa Clara County, California shall have
 * exclusive jurisdiction over any dispute or claim arising out of this
 * Agreement. You may not export the Software in violation of applicable
 * export laws and regulations. 
 * 
 * SECTION 8.3 - AMENDMENT.
 * The Agreement shall not be modified except by a written agreement that
 * names this Agreement and any provision to be modified, is dated
 * subsequent to the Effective Date, and is signed by duly authorized
 * representatives of both parties.
 * 
 * SECTION 8.4 - NO WAIVER.
 * No failure or delay on the part of either party in the exercise of any
 * right, power or remedy under this Agreement or under law, or to insist
 * upon or enforce performance by the other party of any of the provisions
 * of this Agreement or under law, shall operate as a waiver thereof, nor
 * shall any single or partial exercise of any right, power or remedy
 * preclude other or further exercise thereof, or the exercise of any other
 * right, power or remedy; rather the provision, right, or remedy shall be
 * and remain in full force and effect.
 * 
 * SECTION 8.5 - NO ASSIGNMENT. 
 * This Agreement and Licensee’s rights and obligations herein, may not be
 * assigned, subcontracted, delegated, or otherwise transferred by Licensee
 * without NVIDIA’s prior written consent, and any attempted assignment,
 * subcontract, delegation, or transfer in violation of the foregoing will
 * be null and void.  The terms of this Agreement shall be binding upon
 * Licensee’s assignees.
 * 
 * SECTION 8.6 - GOVERNMENT RESTRICTED RIGHTS. 
 * The parties acknowledge that the Software is subject to U.S. export
 * control laws and regulations.   The parties agree to comply with all
 * applicable international and national laws that apply to the Software,
 * including the U.S. Export Administration Regulations, as well as
 * end-user, end-use and destination restrictions issued by U.S. and other
 * governments.
 * 
 * The Software has been developed entirely at private expense and is
 * commercial computer software provided with RESTRICTED RIGHTS. Use,
 * duplication or disclosure of the Software by the U.S. Government or a
 * U.S. Government subcontractor is subject to the restrictions set forth
 * in the Agreement under which the Software was obtained pursuant to DFARS
 * 227.7202-3(a) or as set forth in subparagraphs (c)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR
 * 52.227-19, as applicable. Contractor/manufacturer is NVIDIA, 2701 San
 * Tomas Expressway, Santa Clara, CA 95050. Use of the Software by the
 * Government constitutes acknowledgment of NVIDIA's proprietary rights
 * therein. 
 * 
 * SECTION 8.7 - INDEPENDENT CONTRACTORS.
 * Licensee’s relationship to NVIDIA is that of an independent contractor,
 * and neither party is an agent or partner of the other.  Licensee will
 * not have, and will not represent to any third party that it has, any
 * authority to act on behalf of NVIDIA.
 * 
 * SECTION 8.8 - SEVERABILITY.
 * If for any reason a court of competent jurisdiction finds any provision
 * of this Agreement, or portion thereof, to be unenforceable, that
 * provision of the Agreement will be enforced to the maximum extent
 * permissible so as to affect the intent of the parties, and the remainder
 * of this Agreement will continue in full force and effect. This Agreement
 * has been negotiated by the parties and their respective counsel and will
 * be interpreted fairly in accordance with its terms and without any
 * strict construction in favor of or against either party.
 * 
 * SECTION 8.9 - ENTIRE AGREEMENT.  
 * This Agreement and NDA constitute the entire agreement between the
 * parties with respect to the subject matter contemplated herein, and
 * merges all prior and contemporaneous communications.
 * 
 ******************************************************************************/



#include <oaRPCInternal.h>
#include <oaRPCSocketTransport.h>

#if defined(WIN32) || PLATFORM == OA_WIN32 || PLATFORM == OA_CYGWIN
#include <winsock2.h>
#include <ws2tcpip.h>

#endif

#include <stdlib.h>
#include <stdio.h>

#define IS_SOCKET_VALID( s ) ( (s) != INVALID_SOCKET )
#define IS_SOCKET_INVALID( s ) ( (s) == INVALID_SOCKET )

enum {
  EV_READ     = 1,      ///< Ready for read
  EV_WRITE    = 2,      ///< Ready for write
  EV_OOB      = 4,      ///< Ready for OOB data
  EV_ACCEPT   = 8,      ///< (server)Ready for accept new connections
  EV_CONNECT  = 16,     ///< (client)Connected
  _EV_MAX_VALUE,
};

typedef struct SocketDataStruct
{
  SOCKET    Socket;
  SOCKET    ListenSocket;
  oaBool    Listening;
  oaRPCBuf  *TmpBuf;

#if defined(WIN32) || PLATFORM == OA_WIN32 || PLATFORM == OA_CYGWIN
  HANDLE    CancelEvent;
  HANDLE    SocketEvent;
#else
#error "Events not implemented on this platform!"
#endif
} SocketData;

static void FullSocketCleanup(SocketData *socket);
static oaBool SocketCleanup(SocketData *socket);

#if defined(WIN32) || PLATFORM == OA_WIN32 || PLATFORM == OA_CYGWIN
static int InitCount = 0;
static oaBool InitSocketEnv()
{
  WSADATA       WSAData;

  if(InitCount == 0)
  {
    if( 0 != WSAStartup(MAKEWORD(2,2), &WSAData))
    {
      OARPC_WARNING("WSAStartup failed");
      return OA_FALSE;
    }
  }

  InitCount++;
  return OA_TRUE;
}

static void ExitSocketEnv()
{
  assert(InitCount > 0);
  if(InitCount <= 0)
    return;

  if(--InitCount == 0)
    WSACleanup();
}

static oaRPCTransportErrorType WaitSocket(
  SocketData*   Socket, 
  unsigned long io_events,
  int           time_out_ms)
{
  unsigned long     Flag = 0;
  int               Ret;
  SOCKET            s = Socket->Socket;
  WSANETWORKEVENTS  NetworkEvents;
  HANDLE            Events[2];

  if(io_events & EV_ACCEPT)
  {
    if(io_events != (EV_ACCEPT))
    {
      OARPC_WARNING("Wrong parameter in WaitSocket\n");
      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    Flag = FD_ACCEPT;
    s = Socket->ListenSocket;
  }
  else
  {
    if(io_events & EV_READ)
      Flag |= FD_READ;
    if(io_events & EV_WRITE)
      Flag |= FD_WRITE;
    if(io_events & EV_OOB)
      Flag |= FD_OOB;
    if(io_events & EV_ACCEPT)
      Flag |= FD_ACCEPT;
    if(io_events & EV_CONNECT)
      Flag |= FD_CONNECT;
  }

  if(!Flag || IS_SOCKET_INVALID(s))
  {
    OARPC_WARNING("Wrong parameter in WaitSocket\n");
    return OARPC_TRANSPORT_ERROR_FAILED;
  }

  Events[0] = Socket->SocketEvent;
  Events[1] = Socket->CancelEvent;

  do 
  {
    if(!WSAResetEvent(Socket->SocketEvent))
    {
      OARPC_WARNING("Wrong parameter in WaitSocket\n");
      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    if(SOCKET_ERROR == WSAEventSelect( s, Socket->SocketEvent, Flag | FD_CLOSE ))
    {
      OARPC_WARNING("Wrong parameter in WaitSocket\n");
      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    Ret = WSAWaitForMultipleEvents( 2, Events, FALSE, time_out_ms, FALSE );
    switch(Ret)
    {
    case WSA_WAIT_TIMEOUT: 
      return OARPC_TRANSPORT_ERROR_TIMEOUT;

    case WSA_WAIT_EVENT_0 + 1:
      return OARPC_TRANSPORT_ERROR_CANCELED;

    case WSA_WAIT_EVENT_0:
      break;

    default:
      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    memset( &NetworkEvents, 0, sizeof(NetworkEvents) );
    Ret = WSAEnumNetworkEvents(s, Socket->SocketEvent, &NetworkEvents);
    if(Ret == SOCKET_ERROR)
    {
      OARPC_WARNING("Wrong parameter in WaitSocket\n");
      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    if ( NetworkEvents.lNetworkEvents == FD_CLOSE )
      return OARPC_TRANSPORT_ERROR_FAILED;

    return OARPC_TRANSPORT_ERROR_OK;
  } while(0);

  return OARPC_TRANSPORT_ERROR_FAILED;
}

#else
#define InitSocketEnv()   OA_TRUE
#define ExitSocketEnv()
static oaRPCTransportErrorType WaitSocket(
  SocketData*   Socket, 
  unsigned long io_events,
  int           time_out_ms)
{
#error "WaitSocket not implemented!"
}

static unsigned long GetTickCount()
{
  struct timespec  cur_time;
  clock_gettime( CLOCK_REALTIME, &cur_time );
  return (unsigned long)(cur_time.tv_sec*1000 + cur_time.tv_nsec/1000000);
}

#endif

static SocketData *SocketInit(void)
{
  SocketData    *Socket;

  if(!InitSocketEnv())
    return NULL;

  Socket = (SocketData *)malloc(sizeof(SocketData));
  memset(Socket, 0, sizeof(SocketData));

  Socket->Socket        = INVALID_SOCKET;
  Socket->ListenSocket  = INVALID_SOCKET;

  Socket->TmpBuf = oaRPCAllocBuf();
  if(!Socket->TmpBuf)
  {
    FullSocketCleanup(Socket);
    return NULL;
  }

#if defined(WIN32) || PLATFORM == OA_WIN32 || PLATFORM == OA_CYGWIN
  Socket->CancelEvent   = WSACreateEvent();
  Socket->SocketEvent   = WSACreateEvent();
  if(WSA_INVALID_EVENT == Socket->CancelEvent ||
    WSA_INVALID_EVENT == Socket->SocketEvent)
  {
    FullSocketCleanup(Socket);
    return NULL;
  }
#else
#error "Events not implemented on this platform!"
#endif

  return(Socket);
}

static oaBool SocketCleanup(SocketData *socket)
{
  SocketData *Socket = (SocketData *)socket;

  assert(Socket != NULL);
  if(Socket == NULL)
    return OA_FALSE;

  if(IS_SOCKET_VALID( Socket->Socket) )
  {
    closesocket(Socket->Socket);
    Socket->Socket = INVALID_SOCKET;
  }

  if(IS_SOCKET_VALID( Socket->ListenSocket))
    Socket->Listening = OA_TRUE;

  return(OA_TRUE);
}

static void FullSocketCleanup(SocketData *socket)
{
  SocketData *Socket = (SocketData *)socket;

  assert(Socket != NULL);
  if(Socket == NULL)
    return;

  SocketCleanup(Socket);

  if(WSA_INVALID_EVENT != Socket->CancelEvent)
    WSACloseEvent( Socket->CancelEvent );

  if(WSA_INVALID_EVENT != Socket->SocketEvent)
    WSACloseEvent( Socket->SocketEvent );

  if(Socket->TmpBuf)
    oaRPCFreeBuf(Socket->TmpBuf);

  if(IS_SOCKET_VALID(Socket->ListenSocket))
    closesocket(Socket->ListenSocket);

  free(Socket);
  ExitSocketEnv();
}

static oaRPCTransportErrorType oaRPCSendTimeout(void *user_data, 
                                                const oaRPCBuf *buf, 
                                                int time_out)
{
  SocketData    *Socket = (SocketData *)user_data;

  int           Sent, TotalSent, ToSend, BufSize;
  oaBool        FirstWait = OA_TRUE;
  unsigned long BeginTime = GetTickCount();
  int           WaitTime = time_out;

  oaRPCTransportErrorType Ret;

  assert(Socket != NULL);
  assert(buf != NULL);

  if(IS_SOCKET_INVALID( Socket->Socket ) )
    return(OARPC_TRANSPORT_ERROR_BADTRANSPORT);

  TotalSent = 0;
  BufSize = OARPC_BUF_SIZE(buf);

  oaRPCClearBuf(Socket->TmpBuf);
  oaRPCPushBuf(Socket->TmpBuf, &BufSize, sizeof(BufSize));
  oaRPCPushBuf(Socket->TmpBuf, 
               OARPC_GET_BUF_CONST(buf, 0), 
               OARPC_BUF_SIZE(buf));

  ToSend = OARPC_BUF_SIZE(Socket->TmpBuf);

  while(ToSend > 0)
  {
    Sent = send(
      Socket->Socket, 
      OARPC_GET_BUF(Socket->TmpBuf, TotalSent), 
      ToSend, 
      0);

    if ( Sent == 0 )
      return(OARPC_TRANSPORT_ERROR_FAILED);

    if ( Sent > 0 )
    {
      TotalSent += Sent;
      ToSend -= Sent;
    }
    else
    {
      if ( WSAGetLastError() != WSAEWOULDBLOCK )
        return OARPC_TRANSPORT_ERROR_FAILED;
    }

    if(ToSend == 0)
      return OARPC_TRANSPORT_ERROR_OK;

    // wait...
    if(!FirstWait && time_out > 0)
    {
      WaitTime = time_out - (int)(GetTickCount() - BeginTime);
      if(WaitTime <= 0)
        return OARPC_TRANSPORT_ERROR_TIMEOUT;
    }

    Ret = WaitSocket(Socket, EV_WRITE, WaitTime);
    FirstWait = OA_FALSE;

    if(Ret != OARPC_TRANSPORT_ERROR_OK)
      return(Ret);
  }
  
  return(OARPC_TRANSPORT_ERROR_OK);
}

static oaRPCTransportErrorType AcceptConnection(SocketData *socket, 
                                                int time_out)
{
  oaRPCTransportErrorType ErrCode = OARPC_TRANSPORT_ERROR_OK;

  assert(socket != NULL);
  assert(IS_SOCKET_VALID( socket->ListenSocket ));
  assert(IS_SOCKET_INVALID( socket->Socket));

  ErrCode = WaitSocket(socket, EV_ACCEPT, time_out);
  if(ErrCode != OARPC_TRANSPORT_ERROR_OK)
    return ErrCode;

  socket->Socket = accept(socket->ListenSocket, NULL, NULL);
  if(IS_SOCKET_INVALID( socket->Socket ))
  {
    OARPC_WARNING("accept failed");
    return OARPC_TRANSPORT_ERROR_FAILED;
  }

  return(OARPC_TRANSPORT_ERROR_OK);
}

static oaRPCTransportErrorType oaRPCRecvTimeout(
  void *      user_data, 
  oaRPCBuf *  buf, 
  oaBool *    new_connection, 
  int         time_out )
{
  oaRPCSize       BufSize;
  oaRPCSize       NRead;
  oaRPCSize       TotalRead, TotalLeft;
  SocketData      *Socket = (SocketData *)user_data;
  unsigned long   BeginTime = GetTickCount();
  int             WaitTime = time_out;

  oaRPCTransportErrorType Ret;

  *new_connection = OA_FALSE;

  while(1)
  {
    if(IS_SOCKET_INVALID( Socket->Socket) )
    {
      if(IS_SOCKET_INVALID( Socket->ListenSocket) )
        return(OARPC_TRANSPORT_ERROR_BADTRANSPORT);

      Ret = AcceptConnection(Socket, time_out);
      if(OARPC_TRANSPORT_ERROR_OK != Ret)
        return(Ret);

      *new_connection = OA_TRUE;
    }

    Ret = WaitSocket(Socket, EV_READ, time_out);
    if(OARPC_TRANSPORT_ERROR_OK != Ret)
      return(Ret);

    assert(sizeof(BufSize) == 4);
    NRead = recv(Socket->Socket, (char *)&BufSize, sizeof(BufSize), 0);
    if(NRead == 0)
    {
      if( IS_SOCKET_VALID( Socket->ListenSocket) )
      {
        /* Connection was closed, so accept a new one and continue as normal */
        closesocket(Socket->Socket);
	      Socket->Socket = INVALID_SOCKET;
        continue;
      }

      return OARPC_TRANSPORT_ERROR_FAILED;
    }

    break;
  }

  if(NRead != 4)
    return(OARPC_TRANSPORT_ERROR_BADDATA);

  if(BufSize < 1)
    return(OARPC_TRANSPORT_ERROR_BADDATA);

  oaRPCSetBufSize(buf, BufSize);

  TotalLeft = BufSize;
  TotalRead = 0;
  while(TotalLeft > 0)
  {
    // wait...
    if(!time_out > 0)
    {
      WaitTime = time_out - (int)(GetTickCount() - BeginTime);
      if(WaitTime <= 0)
        return OARPC_TRANSPORT_ERROR_TIMEOUT;
    }

    Ret = WaitSocket(Socket, EV_READ, WaitTime);
    if(OARPC_TRANSPORT_ERROR_OK != Ret)
      return(Ret);

    NRead = recv(Socket->Socket, 
                 OARPC_GET_BUF(buf, TotalRead), 
                 TotalLeft, 
                 0);

    if(NRead < 1)  
      return(OARPC_TRANSPORT_ERROR_BADDATA);

    TotalRead += NRead;
    TotalLeft -= NRead;
  }

  return(OARPC_TRANSPORT_ERROR_OK);
}

static void oaRPCCancelTransmit(void *user_data)
{
  SocketData *Socket = (SocketData *)user_data;
  WSASetEvent( Socket->CancelEvent );
}

oaRPCTransportErrorType oaRPCInitSocketServerTransport(
  oaRPCTransport *transport,
  int port)
{
  SocketData *        Socket;
  struct addrinfo *   Result = NULL, Hints;
  char                PortStr[256];
  int                 Ret;

  oaRPCTransportErrorType ErrCode = OARPC_TRANSPORT_ERROR_OK;

  assert(transport != NULL);
  assert(port > 0);

  memset(transport, 0, sizeof(oaRPCTransport));

  if((Socket = SocketInit()) == NULL)
  {
    OARPC_WARNING("Could not initialize socket library.") 
    return(OARPC_TRANSPORT_ERROR_FAILED);
  }

  memset(&Hints, 0, sizeof(Hints));
  Hints.ai_family = AF_INET;
  Hints.ai_socktype = SOCK_STREAM;
  Hints.ai_protocol = IPPROTO_TCP;
  Hints.ai_flags = AI_PASSIVE;

  sprintf(PortStr, "%d", port);

  if((Ret = getaddrinfo(NULL, PortStr, &Hints, &Result)) != 0) 
  {
    OARPC_WARNING("getaddrinfo() failed.");
    ErrCode = OARPC_TRANSPORT_ERROR_BADADDR;
    goto failed;
  }

  Socket->ListenSocket = socket(Result->ai_family, 
                                Result->ai_socktype, 
                                Result->ai_protocol);

  if(IS_SOCKET_INVALID( Socket->ListenSocket ) ) 
  {
    OARPC_WARNING("Could not open listen socket.");
    ErrCode = OARPC_TRANSPORT_ERROR_FAILED;
    goto failed;
  }

  Ret = bind(Socket->ListenSocket, Result->ai_addr, (int)Result->ai_addrlen);
  if(Ret == SOCKET_ERROR) 
  {
     OARPC_WARNING("bind failed");
     //closesocket(Socket->ListenSocket);
     //Socket->ListenSocket = INVALID_SOCKET;
     ErrCode = OARPC_TRANSPORT_ERROR_BADADDR;
     goto failed;
  }

  freeaddrinfo(Result);
  Result = NULL;

  Ret = listen(Socket->ListenSocket, SOMAXCONN);
  if(Ret == SOCKET_ERROR) 
  {
    OARPC_WARNING("listen failed");
    ErrCode = OARPC_TRANSPORT_ERROR_FAILED;
    goto failed;
  }

  transport->Send     = oaRPCSendTimeout;
  transport->Recv     = oaRPCRecvTimeout;
  transport->Cleanup  = SocketCleanup;
  transport->Cancel   = oaRPCCancelTransmit;
  transport->UserData = (void *)Socket;

  return(OARPC_TRANSPORT_ERROR_OK);

failed:
  if(Result)
    freeaddrinfo(Result);

  FullSocketCleanup(Socket);
  return(ErrCode);
}

oaRPCTransportErrorType oaRPCInitSocketClientTransport(
  oaRPCTransport *transport,
  const char *hostname,
  int port)
{
  SocketData *      Socket;
  struct addrinfo * Result = NULL, *Ptr, Hints;
  int               Ret;
  char              PortStr[256];

  oaRPCTransportErrorType ErrCode = OARPC_TRANSPORT_ERROR_FAILED;

  assert(transport != NULL);
  assert(port > 0);
  assert(hostname != NULL);

  memset(transport, 0, sizeof(oaRPCTransport));

  if((Socket = SocketInit()) == NULL)
  {
    OARPC_ERROR("Could not initialize socket library.");
    ErrCode = OARPC_TRANSPORT_ERROR_FAILED;
    return(OA_FALSE);
  }

  memset(&Hints, 0, sizeof(Hints));
  Hints.ai_family = AF_UNSPEC;
  Hints.ai_socktype = SOCK_STREAM;
  Hints.ai_protocol = IPPROTO_TCP;

  sprintf(PortStr, "%d", port);
  Ret = getaddrinfo(hostname, PortStr, &Hints, &Result);
  if(Ret != 0) 
  {
    OARPC_ERROR("getaddrinfo failed");
    ErrCode = OARPC_TRANSPORT_ERROR_BADADDR;
    goto failed;
  }

  // Attempt to connect to an address until one succeeds
  for(Ptr=Result; Ptr != NULL ; Ptr=Ptr->ai_next) 
  {
    Socket->Socket = socket(
      Ptr->ai_family, 
      Ptr->ai_socktype, 
      Ptr->ai_protocol);
    if(IS_SOCKET_INVALID(Socket->Socket) ) 
    {
      OARPC_ERROR("Error at socket()");
      ErrCode = OARPC_TRANSPORT_ERROR_BADADDR;
      goto failed;
    }
/*
    ErrCode = WaitSocket(Socket, EV_CONNECT, -1);
    if(ErrCode != OARPC_TRANSPORT_ERROR_OK)
      goto failed;
*/
    Ret = connect(Socket->Socket, Ptr->ai_addr, (int)Ptr->ai_addrlen);
    if(Ret == SOCKET_ERROR) 
    {
      closesocket(Socket->Socket);
      Socket->Socket = INVALID_SOCKET;
      continue;
    }

    break;
  }

  if(IS_SOCKET_INVALID( Socket->Socket))
    goto failed;

  transport->Send     = oaRPCSendTimeout;
  transport->Recv     = oaRPCRecvTimeout;
  transport->Cleanup  = SocketCleanup;
  transport->Cancel   = oaRPCCancelTransmit;
  transport->UserData = (void *)Socket;

  freeaddrinfo(Result);

  return(OARPC_TRANSPORT_ERROR_OK);

failed:
  if(Result)
    freeaddrinfo(Result);

  FullSocketCleanup(Socket);
  return(ErrCode);
}

void oaRPCCleanupTransport(oaRPCTransport* transport)
{
  assert(transport != NULL);
  assert(transport->UserData != NULL);

  FullSocketCleanup((SocketData *)transport->UserData);
}
