/*******************************************************************************
 * NVIDIA Corporation 
 * Software License Agreement - OpenAutomate SDK 
 * 
 * IMPORTANT - READ BEFORE COPYING, INSTALLING OR USING
 * Do not use or load the OpenAutomate SDK and any associated materials
 * provided by NVIDIA on NVIDIA’s website (collectively, the "Software")
 * until You have carefully read the following terms and conditions. By
 * loading or using the Software, You agree to fully comply with the terms
 * and conditions of this Software License Agreement ("Agreement") by and
 * between NVIDIA Corporation, a Delaware corporation with its principal
 * place of business at 2701 San Tomas Expressway, Santa Clara, California
 * 95050 U.S.A. ("NVIDIA"), and You. If You do not wish to so agree, do not
 * install or use the Software. 
 * 
 * For the purposes of this Agreement: 
 * 
 * "Licensee," "You" and/or "Your" shall mean, collectively and
 * individually, Original Equipment Manufacturers, Independent Hardware
 * Vendors, Independent Software Vendors, and End-Users of the Software
 * pursuant to the terms and conditions of this Agreement.   
 * 
 * "Derivative Works" shall mean derivatives of the Software created by You
 * or a third party on Your behalf, which term shall include:  (a) for
 * copyrightable or copyrighted material, any translation, abridgement,
 * revision or other form in which an existing work may be recast,
 * transformed or adapted; (b) for work protected by topography or mask
 * right, any translation, abridgement, revision or other form in which an
 * existing work may be recast, transformed or adapted; (c) for patentable
 * or patented material, any Improvement; and (d) for material protected by
 * trade secret, any new material derived from or employing such existing
 * trade secret.
 * 
 * "Excluded License" is any license that requires as a condition of use,
 * modification and/or distribution of software subject to the Excluded
 * License, that such software or other software distributed and/or
 * combined with such software be (i) disclosed or distributed in source
 * code form, (ii) licensed for the purpose of making derivative works, or
 * (iii) redistributable at no charge.
 * 
 * SECTION 1 - GRANT OF LICENSE.
 * NVIDIA agrees to provide the Software and any associated materials
 * pursuant to the terms and conditions of this Agreement.  Subject to the
 * terms of this Agreement, NVIDIA grants to You a nonexclusive,
 * transferable, worldwide, revocable, limited, royalty-free, fully paid-up
 * license under NVIDIA’s copyrights to 
 * 
 * (a) install, deploy, use, have used execute, reproduce, display,
 * perform, run, modify the source code of the Software, or to prepare and
 * have prepared Derivative Works thereof the Software for Your own
 * internal development, testing and maintenance purposes to incorporate
 * the Software or Derivative Works thereof, in part or whole, into Your
 * software applications; 
 * 
 * (b)	 to transfer, distribute and sublicense the Software (in its
 * unmodified form as delivered to You by NVIDIA pursuant to this
 * Agreement) in any medium or technology for Your sublicensees to
 * incorporate the Software or Derivative Works thereof, in part or whole,
 * into their respective software applications; and
 * 
 * (c) to transfer, distribute and sublicense Derivative Works (in object
 * code only) of the Software (i)_as incorporated in Your application
 * software in any medium or technology; and (ii) certified as OpenAutomate
 * Compatible Software.
 * 
 * You may exercise your license rights pursuant to Subsection 1(b) and (c)
 * above pursuant to the terms and conditions of any form of end-user
 * software license agreement of Your choice, including but not limited to
 * an Excluded License.
 * 
 * In the event NVIDIA certifies Your application software, incorporating
 * the Derivative Works (in object code only) of the Software, as
 * OpenAutomate compatible ("OpenAutomate Compatible Software"), NVIDIA
 * grants You a nonexclusive, worldwide, revocable, paid-up license to use
 * the name and trademark to "OpenAutomate Compatible" solely for the
 * purposes of identifying and/or marketing Your application software as
 * OpenAutomate Compatible Software; provided that Licensee fully complies
 * with the following:	
 * 
 * (x) Licensee agrees that it is strictly prohibited from using the name
 * and trademark of "OpenAutomate Compatible" if Your application software
 * is not OpenAutomate Compatible Software;
 * 
 * (y) if NVIDIA objects to Your improper use of the "OpenAutomate
 * Compatible" name and trademark, You will take all reasonable steps
 * necessary to resolve NVIDIA’s objections. NVIDIA may reasonably monitor
 * the quality of Your application software bearing the "OpenAutomate
 * Compatible" name or trademark pursuant to this Agreement; and
 * 
 * (z) any goodwill attached to NVIDIA’s trademarks, service marks, or
 * trade names belong to NVIDIA and this Agreement does not grant You any
 * right to use them.
 * 
 * If You are not the final manufacturer or vendor of a computer system or
 * software program incorporating the Software, or if Your Contractors (as
 * defined below), affiliates or subsidiaries need to exercise any, some or
 * all of the license grant described above herein to the Software on Your
 * behalf, then You may transfer a copy of the Software, (and related
 * end-user documentation) to such recipient for use in accordance with the
 * terms of this Agreement, provided such recipient agrees to be fully
 * bound by the terms hereof. Except as expressly permitted in this
 * Agreement, Unless otherwise authorized in the Agreement, You shall not
 * otherwise assign, sublicense, lease, or in any other way transfer or
 * disclose Software to any third party. Unless otherwise authorized in the
 * Agreement, You shall not reverse- compile, disassemble,
 * reverse-engineer, or in any manner attempt to derive the source code of
 * the Software from the object code portions of the Software. 
 * 
 * Except as expressly stated in this Agreement, no license or right is
 * granted to You directly or by implication, inducement, estoppel or
 * otherwise. NVIDIA shall have the right to inspect or have an independent
 * auditor inspect Your relevant records to verify Your compliance with the
 * terms and conditions of this Agreement. 
 * 
 * SECTION 2 - CONFIDENTIALITY.
 * If applicable, any exchange of Confidential Information (as defined in
 * the NDA) shall be made pursuant to the terms and conditions of a
 * separately signed Non-Disclosure Agreement ("NDA") by and between NVIDIA
 * and You. For the sake of clarity, You agree that the Software is
 * Confidential Information of NVIDIA.
 * 
 * If You wish to have a third party consultant or subcontractor
 * ("Contractor") perform work on Your behalf which involves access to or
 * use of Software, You shall obtain a written confidentiality agreement
 * from the Contractor which contains terms and obligations with respect to
 * access to or use of Software no less restrictive than those set forth in
 * this Agreement and excluding any distribution or sublicense rights, and
 * use for any other purpose than permitted in this Agreement. Otherwise,
 * You shall not disclose the terms or existence of this Agreement or use
 * NVIDIA's name in any publications, advertisements, or other
 * announcements without NVIDIA's prior written consent.  Unless otherwise
 * provided in this Agreement, You do not have any rights to use any NVIDIA
 * trademarks or logos.
 * 
 * SECTION 3 - OWNERSHIP OF SOFTWARE AND INTELLECTUAL PROPERTY RIGHTS.
 * All rights, title and interest to all copies of the Software remain with
 * NVIDIA, subsidiaries, licensors, or its suppliers. The Software is
 * copyrighted and protected by the laws of the United States and other
 * countries, and international treaty provisions. You may not remove any
 * copyright notices from the Software. NVIDIA may make changes to the
 * Software, or to items referenced therein, at any time and without
 * notice, but is not obligated to support or update the Software. Except
 * as otherwise expressly provided, NVIDIA grants no express or implied
 * right under any NVIDIA patents, copyrights, trademarks, or other
 * intellectual property rights. 
 * 
 * All rights, title and interest in the Derivative Works of the Software
 * remain with You subject to the underlying license from NVIDIA to the
 * Software.  In Your sole discretion, You may grant NVIDIA, upon NVIDIA’s
 * request for such a license described herein, an irrevocable, perpetual,
 * nonexclusive, worldwide, royalty-free paid-up license to make, have
 * made, use, have used, sell, license, distribute, sublicense or otherwise
 * transfer Derivative Works created by You that add functionality or
 * improvement to the Software.  
 * 
 * You has no obligation to give NVIDIA any suggestions, comments or other
 * feedback ("Feedback") relating to the Software.  However, NVIDIA may use
 * and include any Feedback that You voluntarily provide to improve the
 * Software or other related NVIDIA technologies.  Accordingly, if You
 * provide Feedback, You agree NVIDIA and its licensees may freely use,
 * reproduce, license, distribute, and otherwise commercialize the Feedback
 * in the Software or other related technologies without the payment of any
 * royalties or fees.  
 * 
 * You may transfer the Software only if the recipient agrees to be fully
 * bound by these terms and conditions of this Agreement. 
 * 
 * SECTION 4 - NO WARRANTIES. 
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY
 * OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT,
 * OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA does not warrant or assume
 * responsibility for the accuracy or completeness of any information,
 * text, graphics, links or other items contained within the Software.
 * NVIDIA does not represent that errors or other defects will be
 * identified or corrected.
 * 
 * SECTION 5 - LIMITATION OF LIABILITY.
 * EXCEPT WITH RESPECT TO THE MISUSE OF THE OTHER PARTY’S INTELLECTUAL
 * PROPERTY OR DISCLOSURE OF THE OTHER PARTY’S CONFIDENTIAL INFORMATION IN
 * BREACH OF THIS AGREEMENT, IN NO EVENT SHALL NVIDIA, SUBSIDIARIES,
 * LICENSORS, OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION,  INDIRECT, LOST PROFITS, CONSEQUENTIAL,
 * BUSINESS INTERRUPTION OR LOST INFORMATION) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THE SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS PROHIBIT EXCLUSION OR
 * LIMITATION OF LIABILITY FOR IMPLIED WARRANTIES OR CONSEQUENTIAL OR
 * INCIDENTAL DAMAGES, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU. YOU
 * MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM JURISDICTION TO
 * JURISDICTION.  NOTWITHSTANDING THE FOREGOING, NVIDIA’S AGGREGATE
 * LIABILITY ARISING OUT OF THIS AGREEMENT SHALL NOT EXCEED ONE HUNDRED
 * UNITED STATES DOLLARS (USD$100).
 * 
 * SECTION 6 - TERM.
 * This Agreement and the licenses granted hereunder shall be effective as
 * of the date You download the applicable Software ("Effective Date") and
 * continue for a period of one (1) year ("Initial Term") respectively,
 * unless terminated earlier in accordance with the "Termination" provision
 * of this Agreement.  Unless either party notifies the other party of its
 * intent to terminate this Agreement at least three (3) months prior to
 * the end of the Initial Term or the applicable renewal period, this
 * Agreement will be automatically renewed for one (1) year renewal periods
 * thereafter, unless terminated in accordance with the "Termination"
 * provision of this Agreement.  
 * 
 * SECTION 7 - TERMINATION.
 * NVIDIA may terminate this Agreement at any time if You violate its
 * terms. Upon termination, You will immediately destroy the Software or
 * return all copies of the Software to NVIDIA, and certify to NVIDIA in
 * writing that such actions have been completed.  Upon termination or
 * expiration of this Agreement the license grants to Licensee shall
 * terminate, except that sublicenses rightfully granted by Licensee under
 * this Agreement in connection with Section 1(b) and (c) of this Agreement
 * provided by Licensee prior to the termination or expiration of this
 * Agreement shall survive in accordance with their respective form of
 * license terms and conditions.
 * 
 * SECTION 8 - MISCELLANEOUS.
 * 
 * SECTION 8.1 - SURVIVAL.
 * Those provisions in this Agreement, which by their nature need to
 * survive the termination or expiration of this Agreement, shall survive
 * termination or expiration of the Agreement, including but not limited to
 * Sections 2, 3, 4, 5, 7, and 8.
 * 
 * SECTION 8.2 - APPLICABLE LAWS.
 * Claims arising under this Agreement shall be governed by the laws of
 * Delaware, excluding its principles of conflict of laws and the United
 * Nations Convention on Contracts for the Sale of Goods. The state and/or
 * federal courts residing in Santa Clara County, California shall have
 * exclusive jurisdiction over any dispute or claim arising out of this
 * Agreement. You may not export the Software in violation of applicable
 * export laws and regulations. 
 * 
 * SECTION 8.3 - AMENDMENT.
 * The Agreement shall not be modified except by a written agreement that
 * names this Agreement and any provision to be modified, is dated
 * subsequent to the Effective Date, and is signed by duly authorized
 * representatives of both parties.
 * 
 * SECTION 8.4 - NO WAIVER.
 * No failure or delay on the part of either party in the exercise of any
 * right, power or remedy under this Agreement or under law, or to insist
 * upon or enforce performance by the other party of any of the provisions
 * of this Agreement or under law, shall operate as a waiver thereof, nor
 * shall any single or partial exercise of any right, power or remedy
 * preclude other or further exercise thereof, or the exercise of any other
 * right, power or remedy; rather the provision, right, or remedy shall be
 * and remain in full force and effect.
 * 
 * SECTION 8.5 - NO ASSIGNMENT. 
 * This Agreement and Licensee’s rights and obligations herein, may not be
 * assigned, subcontracted, delegated, or otherwise transferred by Licensee
 * without NVIDIA’s prior written consent, and any attempted assignment,
 * subcontract, delegation, or transfer in violation of the foregoing will
 * be null and void.  The terms of this Agreement shall be binding upon
 * Licensee’s assignees.
 * 
 * SECTION 8.6 - GOVERNMENT RESTRICTED RIGHTS. 
 * The parties acknowledge that the Software is subject to U.S. export
 * control laws and regulations.   The parties agree to comply with all
 * applicable international and national laws that apply to the Software,
 * including the U.S. Export Administration Regulations, as well as
 * end-user, end-use and destination restrictions issued by U.S. and other
 * governments.
 * 
 * The Software has been developed entirely at private expense and is
 * commercial computer software provided with RESTRICTED RIGHTS. Use,
 * duplication or disclosure of the Software by the U.S. Government or a
 * U.S. Government subcontractor is subject to the restrictions set forth
 * in the Agreement under which the Software was obtained pursuant to DFARS
 * 227.7202-3(a) or as set forth in subparagraphs (c)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR
 * 52.227-19, as applicable. Contractor/manufacturer is NVIDIA, 2701 San
 * Tomas Expressway, Santa Clara, CA 95050. Use of the Software by the
 * Government constitutes acknowledgment of NVIDIA's proprietary rights
 * therein. 
 * 
 * SECTION 8.7 - INDEPENDENT CONTRACTORS.
 * Licensee’s relationship to NVIDIA is that of an independent contractor,
 * and neither party is an agent or partner of the other.  Licensee will
 * not have, and will not represent to any third party that it has, any
 * authority to act on behalf of NVIDIA.
 * 
 * SECTION 8.8 - SEVERABILITY.
 * If for any reason a court of competent jurisdiction finds any provision
 * of this Agreement, or portion thereof, to be unenforceable, that
 * provision of the Agreement will be enforced to the maximum extent
 * permissible so as to affect the intent of the parties, and the remainder
 * of this Agreement will continue in full force and effect. This Agreement
 * has been negotiated by the parties and their respective counsel and will
 * be interpreted fairly in accordance with its terms and without any
 * strict construction in favor of or against either party.
 * 
 * SECTION 8.9 - ENTIRE AGREEMENT.  
 * This Agreement and NDA constitute the entire agreement between the
 * parties with respect to the subject matter contemplated herein, and
 * merges all prior and contemporaneous communications.
 * 
 ******************************************************************************/



#include <oaRPCInternal.h>

#if defined(WIN32) || PLATFORM == OA_WIN32 || PLATFORM == OA_CYGWIN
# include <Windows.h>
# define   GET_TICKCOUNT   GetTickCount()
#else
# error "GET_TICKCOUNT not defined in this platform"
#endif

#ifndef NDEBUG

#  define PRINT_INT(var) \
  fprintf(stderr, "%s, %d: " #var " = %d\n",__FILE__, __LINE__, (var)); \
  fflush(stderr);

#  define MSG(msg) \
  fprintf(stderr, "%s, %d: %s\n",__FILE__, __LINE__, (msg)); \
  fflush(stderr);

#else
#  define PRINT_INT(val) 
#  define MSG(msg) 
#endif

#define DUMP_REQUEST(req_buf, filename)   \
  if(filename) oaRPCDumpRequest(req_buf, filename);

#define DUMP_RESPONSE(req_buf, filename)  \
  if(filename) oaRPCDumpResponse(req_buf, filename);

#define SERIALIZE_RESPONSE_HEADER(error_code, error_str) \
  assert(send_buf); \
  oaRPCSerializeInt(send_buf, error_code); \
  oaRPCSerializeString(send_buf, error_str);

#define CHECK_BUF_SAFE(buf,type)  \
  if((buf)->Size - Offset < 5 + sizeof(type)) \
  { \
    Ret = OARPC_SERVER_ERROR_BADREQUEST;  \
    break;\
  } \

#define SHIFT_STRING_PARAM(buf, dst) \
  if((buf)->Size - Offset < 5) \
  { \
    OARPC_WARNING("Message did not have enough bytes.  Expected data of " \
      "type 'string'."); \
    break;  \
  } \
  (dst) = oaRPCDeserializeString((buf), &Offset); 

#define SHIFT_INT_PARAM(buf, dst) \
  CHECK_BUF_SAFE(buf,oaInt); \
  (dst) = oaRPCDeserializeInt((buf), &Offset);

#define SHIFT_BOOL_PARAM(buf, dst) \
  CHECK_BUF_SAFE(buf, oaRPCUInt8) \
  (dst) = oaRPCDeserializeBool((buf), &Offset); 

#define SHIFT_FLOAT_PARAM(buf, dst) \
  CHECK_BUF_SAFE(buf, oaFloat) \
  (dst) = oaRPCDeserializeFloat((buf), &Offset); 

#define SHIFT_VALUE_PARAM(buf, type, dst) \
  { \
    oaOptionDataType DESERIALIZE_VALUE_Type; \
    CHECK_BUF_SAFE(buf, oaInt) \
    (dst) = oaRPCDeserializeValue((buf), &DESERIALIZE_VALUE_Type, &Offset);  \
    type = DESERIALIZE_VALUE_Type; \
  }

/*******************************************************************************
*** Prototypes
******************************************************************************/
static void oaRPCDumpRequest(const oaRPCBuf *request, const char* file_name);
static void oaRPCDumpResponse(const oaRPCBuf *response, const char* file_name);
static oaRPCServerErrorType TransportErrCode2ServerErrCode(
  oaRPCTransportErrorType ts_err);
static oaRPCTransportErrorType oaRPCRecvData(oaRPCServer* server, 
                                             oaRPCBuf *buf, 
                                             int time_out);

static oaRPCServerErrorType 
oaRPCDispatch(oaRPCFuncType func_id, 
              oaRPCBuf *recv_buf,
              oaInt offset,
              oaRPCBuf *send_buf,
              const oaRPCFunctionTable *func_table,
              oaBool *exit_loop);

static oaBool SerializeGetNextCommandResponse(const oaCommand *command, 
                                              oaRPCBuf *send_buf);

static oaBool oaRPCServerNegotiate(oaRPCServer* server, 
                                   const oaRPCBuf *request, 
                                   oaRPCBuf *response);

/*******************************************************************************
*** RPC Server-side Functions
******************************************************************************/

oaRPCServer *oaRPCCreateServer(const oaRPCFunctionTable *func_table, 
                               oaRPCTransport *transport, 
                               const char *log_filename)
{
  oaRPCServer *Ret = (oaRPCServer *)malloc(sizeof(oaRPCServer));

  assert(func_table);
  assert(transport);

  memset(Ret, 0, sizeof(oaRPCServer));

  Ret->FuncTable = func_table;
  Ret->Transport = transport;
  Ret->LogFilename = strdup(log_filename);

  Ret->CurDepth = 0;

  return(Ret);
}

oaRPCServerErrorType oaRPCRunServer(oaRPCServer *server, int IO_time_out)
{
  oaRPCBuf *RecvBuf = oaRPCAllocBuf();
  oaRPCBuf *SendBuf = oaRPCAllocBuf();
  const oaRPCBuf *PreResponseBuf = NULL;
  oaRPCSize Offset = 0; 
  oaBool ExitLoop = OA_FALSE;

  const oaRPCFunctionTable *FuncTable;
  oaRPCTransport *Transport;
  void *UserData;
  const char *LogFilename;

  oaRPCServerErrorType    SvrErrCode = OARPC_SERVER_ERROR_OK;
  oaRPCTransportErrorType TsErrCode;

  assert(server);
  assert(server->CurDepth < OARPC_MAX_CALL_DEPTH);

  FuncTable = server->FuncTable;
  Transport = server->Transport;
  UserData = server->Transport->UserData;
  LogFilename = server->LogFilename;

  server->InternalParam = IO_time_out;

  PreResponseBuf = server->CallStack[server->CurDepth].PreResponseBuf;

  /* if PreResponseBuf was defined, send the response before starting
  the request/response loop.  This is for the case where 
  oaRPCServerNestCommand() was called. */
  if(PreResponseBuf != NULL)
  {
    DUMP_RESPONSE(PreResponseBuf, LogFilename);

    TsErrCode = Transport->Send(Transport->UserData, PreResponseBuf, IO_time_out);
    if(TsErrCode != OARPC_TRANSPORT_ERROR_OK)
    {
      Transport->Cleanup(UserData);
      oaRPCFreeBuf(RecvBuf);
      oaRPCFreeBuf(SendBuf);
      return TransportErrCode2ServerErrCode(TsErrCode);
    }
    server->CallStack[server->CurDepth].PreResponseBuf = NULL;
  }

  while(1)
  {
    oaInt FuncId;

    TsErrCode = oaRPCRecvData(server, RecvBuf, IO_time_out);
    if(TsErrCode != OARPC_TRANSPORT_ERROR_OK)
    {
      SvrErrCode = TransportErrCode2ServerErrCode(TsErrCode);
      break;
    }

    DUMP_REQUEST(RecvBuf, LogFilename);
    if((RecvBuf)->Size - Offset < 5 + sizeof(oaInt))
    {
      SvrErrCode = OARPC_SERVER_ERROR_BADREQUEST;
      break;
    }
    FuncId = oaRPCDeserializeInt(RecvBuf, &Offset);

    /* If we were called from oaRPCServerNestCommand(), we must return control
    when a request for GetNextCommand() is made. */
    if(PreResponseBuf && FuncId == OARPC_FUNC_GET_NEXT_COMMAND)
    {
      oaRPCFreeBuf(RecvBuf);
      oaRPCFreeBuf(SendBuf);
      return OARPC_SERVER_ERROR_OK;
    }

    server->CallStack[server->CurDepth].Func = FuncId;
    server->CurDepth++;

    SvrErrCode = oaRPCDispatch(
      (oaRPCFuncType)FuncId, 
      RecvBuf, 
      Offset, 
      SendBuf, 
      FuncTable, 
      &ExitLoop);

    if(SvrErrCode == OARPC_SERVER_ERROR_OK)
    {
      DUMP_RESPONSE(SendBuf, LogFilename);

      TsErrCode = Transport->Send(Transport->UserData, SendBuf, IO_time_out);
      if(OARPC_TRANSPORT_ERROR_OK != TsErrCode)
      {
        SvrErrCode = TransportErrCode2ServerErrCode(TsErrCode);
        break;
      }
    }
    else
    {
      break;
    }

    server->CurDepth--;

    if(ExitLoop)
    {
      ExitLoop = OA_FALSE;
      break;
    }

    oaRPCClearBuf(RecvBuf);
    oaRPCClearBuf(SendBuf);
    Offset = 0;
  }

  Transport->Cleanup(UserData);
  oaRPCFreeBuf(RecvBuf);
  oaRPCFreeBuf(SendBuf);

  return(SvrErrCode);
}

void oaRPCStopServer(oaRPCServer *server)
{
  oaRPCTransport *Transport;

  assert(server);
  assert(server->CurDepth < OARPC_MAX_CALL_DEPTH);

  Transport = server->Transport;
  Transport->Cancel(Transport->UserData);
}

oaRPCServerErrorType oaRPCServerNestCommand(oaRPCServer *server, const oaCommand *command)
{
  oaRPCServerErrorType Ret;
  oaRPCBuf *SendBuf = oaRPCAllocBuf();

  assert(command != NULL);
  assert(server != NULL);
  assert(server->CurDepth > 0);
  assert(server->CallStack[server->CurDepth-1].Func == 
    OARPC_FUNC_GET_NEXT_COMMAND);

  SerializeGetNextCommandResponse(command, SendBuf);
  server->CallStack[server->CurDepth].PreResponseBuf = SendBuf;

  Ret = oaRPCRunServer(server, server->InternalParam);

  oaRPCFreeBuf(SendBuf);

  return(Ret);
}

oaRPCServerErrorType oaRPCServerSendExitCommand(oaRPCServer *server,
                                                oaBool (*post_exit_func)(void *),
                                                void *data)
{
  const oaRPCFunctionTable *FuncTable;
  oaRPCTransport *Transport;
  const char *LogFilename;
  oaRPCBuf *SendBuf = oaRPCAllocBuf();
  oaRPCBuf *RecvBuf = oaRPCAllocBuf();
  oaCommand Command;
  oaRPCSize Offset = 0;

  oaRPCServerErrorType    SvrErrCode = OARPC_SERVER_ERROR_OK;
  oaRPCTransportErrorType TsErrCode;
  oaInt FuncId;

  assert(server != NULL);
  assert(server->CurDepth > 0);
  assert(server->CallStack[server->CurDepth-1].Func == 
    OARPC_FUNC_GET_NEXT_COMMAND);

  FuncTable = server->FuncTable;
  Transport = server->Transport;
  LogFilename = server->LogFilename;

  oaInitCommand(&Command);
  Command.Type = OA_CMD_EXIT;
  SerializeGetNextCommandResponse(&Command, SendBuf);

  DUMP_RESPONSE(SendBuf, LogFilename);

  do 
  {
    TsErrCode = Transport->Send(Transport->UserData, SendBuf, server->InternalParam);
    if(OARPC_TRANSPORT_ERROR_OK != TsErrCode)
    {
      SvrErrCode = TransportErrCode2ServerErrCode(TsErrCode);
      break;
    }

    if(post_exit_func != NULL)
    {
      if(post_exit_func(data) != OA_TRUE)
      {
        SvrErrCode = OARPC_SERVER_ERROR_FAILED;
        break;
      }
    }

    // Cleanup socket.
    Transport->Cleanup(Transport->UserData);

    TsErrCode = oaRPCRecvData(server, RecvBuf, server->InternalParam);
    if(OARPC_TRANSPORT_ERROR_OK != TsErrCode)
    {
      SvrErrCode = TransportErrCode2ServerErrCode(TsErrCode);
      break;
    }

    DUMP_REQUEST(RecvBuf, LogFilename);
    if((RecvBuf)->Size - Offset < 5 + sizeof(oaInt))
    {
      SvrErrCode = OARPC_SERVER_ERROR_BADREQUEST;
      break;
    }

    FuncId = oaRPCDeserializeInt(RecvBuf, &Offset);
    if(FuncId != OARPC_FUNC_GET_NEXT_COMMAND)
      SvrErrCode = OARPC_SERVER_ERROR_FAILED;
  } while(0);

  oaRPCFreeBuf(SendBuf);
  oaRPCFreeBuf(RecvBuf);

  return(SvrErrCode);
}

oaBool oaRPCDestroyServer(oaRPCServer *server)
{
  assert(server);
  free(server);

  return(OA_TRUE);
}

/*******************************************************************************
*** Local Functions
******************************************************************************/
#define PUSH_BUF_STR(buf, str) oaRPCPushBuf(buf, str, (oaRPCSize)strlen(str))

static const char *FuncIdToStr(oaInt func_id)
{
  switch(func_id)
  {
#define OARPC_DECLARE_FUNC(func_name, func_id) \
    case func_id : \
    return(#func_name);

#include "oaRPC_Functions.h"
  };

  return("UNKNOWN FUNC");
}

static void oaRPCPrintParams(const oaRPCBuf *buf, oaRPCBuf *ret, oaInt *offset)
{
  oaRPCSize BufSize = OARPC_BUF_SIZE(buf);
  oaInt ParamCount = 0;

  while(BufSize - *offset >= 5)
  {
    oaRPCSize TmpOffset = *offset;
    oaRPCUInt8 Type;
    oaInt Size;
    char Msg[4096];

    DESERIALIZE_VALUE_HEADER(buf, Type, Size, &TmpOffset);

    switch((oaOptionDataType)Type)
    {
    case OA_TYPE_STRING :
      sprintf(Msg, "Param %d (string[%d]): \"%s\"\n", 
        ParamCount, Size, 
        oaRPCDeserializeString(buf, offset));
      break;

    case OA_TYPE_INT :
      sprintf(Msg, "Param %d (int[%d]): %d\n", 
        ParamCount, Size, 
        oaRPCDeserializeInt(buf, offset));
      break;

    case OA_TYPE_FLOAT :
      sprintf(Msg, "Param %d (float[%d]): %f\n", 
        ParamCount, Size, 
        oaRPCDeserializeFloat(buf, offset));
      break;

    case OA_TYPE_BOOL :
      sprintf(Msg, "Param %d (bool[%d]): %s\n", 
        ParamCount, Size, 
        (oaRPCDeserializeBool(buf, offset) == OA_TRUE) ? "TRUE" : "FALSE" );
      break;

    default:
      assert("Unknown type!" == NULL);
    }

    PUSH_BUF_STR(ret, Msg);
    ParamCount++;
  }
}

void oaRPCDumpRequest(const oaRPCBuf *request, const char* file_name)
{
  oaBool Ret; 
  oaRPCBuf *Tmp = oaRPCAllocBuf(); 

  oaRPCSize Offset = 0;
  char Msg[4096];
  oaRPCSize ReqSize;
  oaInt FuncId;
  oaInt ParamCount = 0;

  if(!file_name)
    return;

  assert(request != NULL);

  ReqSize = OARPC_BUF_SIZE(request);

  if(ReqSize < 9)
  {
    PUSH_BUF_STR(Tmp, "ERROR: Not enough bytes for function id.\n");
    return;
  }

  sprintf(Msg, "-- REQUEST\nRequest size: %d\n", ReqSize);
  PUSH_BUF_STR(Tmp, Msg);

  if(request->Size - Offset < 5 + sizeof(oaInt))
    return;
  FuncId = oaRPCDeserializeInt(request, &Offset);
  sprintf(Msg, "Function id: %d\n", FuncId);
  PUSH_BUF_STR(Tmp, Msg);

  sprintf(Msg, "Function name: %s\n", FuncIdToStr(FuncId));
  PUSH_BUF_STR(Tmp, Msg);

  oaRPCPrintParams(request, Tmp, &Offset);
  if(ReqSize != Offset)
  {
    sprintf(Msg, "ERROR: There are an extra %d bytes at the tail of the "
      "request.\n", (ReqSize - Offset));
    PUSH_BUF_STR(Tmp, Msg);
  }

  Ret = oaRPCWriteBufToFile(file_name, Tmp, OA_TRUE); 
  assert(Ret); 

  oaRPCFreeBuf(Tmp); 
}

void oaRPCDumpResponse(const oaRPCBuf *response, const char* file_name)
{
  oaBool Ret; 
  oaRPCBuf *Tmp = oaRPCAllocBuf(); 

  oaRPCSize Offset = 0;
  char Msg[4096];
  oaRPCSize RespSize;
  oaInt ErrorCode;
  const oaChar *ErrorStr;
  oaInt ParamCount = 0;

  if(!file_name)
    return;

  assert(response != NULL);
  assert(Tmp != NULL);

  RespSize = OARPC_BUF_SIZE(response);

  if(RespSize < 14)
  {
    PUSH_BUF_STR(Tmp, "ERROR: Not enough bytes for error code and string.\n");
    return;
  }

  sprintf(Msg, "-- RESPONSE\nResponse size: %d\n", RespSize);
  PUSH_BUF_STR(Tmp, Msg);

  if(response->Size - Offset < 5 + sizeof(oaInt))
    return;
  ErrorCode = oaRPCDeserializeInt(response, &Offset);
  sprintf(Msg, "Error code: %d\n", ErrorCode);
  PUSH_BUF_STR(Tmp, Msg);

  if(response->Size - Offset < 5)
    return;
  ErrorStr = oaRPCDeserializeString(response, &Offset);
  sprintf(Msg, "Error string: \"%s\"\n", ErrorStr);
  PUSH_BUF_STR(Tmp, Msg);

  oaRPCPrintParams(response, Tmp, &Offset);

  if(RespSize != Offset)
  {
    sprintf(Msg, "ERROR: There are an extra %d bytes at the tail of the "
      "response.\n", (RespSize - Offset));
    PUSH_BUF_STR(Tmp, Msg);
  }

  Ret = oaRPCWriteBufToFile(file_name, Tmp, OA_TRUE); 
  assert(Ret); 

  oaRPCFreeBuf(Tmp); 
}

oaRPCServerErrorType TransportErrCode2ServerErrCode(
  oaRPCTransportErrorType ts_err)
{
  switch(ts_err)
  {
  case OARPC_TRANSPORT_ERROR_OK:
    return OARPC_SERVER_ERROR_OK;
  case OARPC_TRANSPORT_ERROR_CANCELED:
    return OARPC_SERVER_ERROR_CANCELED;
  case OARPC_TRANSPORT_ERROR_TIMEOUT:
    return OARPC_SERVER_ERROR_TIMEOUT;
  default:
    return OARPC_SERVER_ERROR_TSFAILED;
  }
}

oaRPCTransportErrorType oaRPCRecvData(oaRPCServer* server, oaRPCBuf *buf, int time_out)
{
  oaBool NewConnection = OA_FALSE;
  oaRPCTransportErrorType TsRet;
  oaRPCServerErrorType    SvrRet;
  int     time_left = 0;
  unsigned long   StartTime = GET_TICKCOUNT;

  oaRPCTransport *transport = server->Transport;

  TsRet = transport->Recv(transport->UserData, buf, &NewConnection, time_out);
  if(TsRet != OARPC_TRANSPORT_ERROR_OK)
    return TsRet;

  if ( time_out >= 0 )
  {
    time_out  -= (int)(GET_TICKCOUNT - StartTime);
    if( time_out <= 0 )
      return OARPC_TRANSPORT_ERROR_TIMEOUT;
  }

  /* Negotiate the oaRPC and OA version if it's a new connection */
  if(NewConnection == OA_TRUE)
  {
    oaRPCBuf *Response = oaRPCAllocBuf();
    SvrRet = oaRPCServerNegotiate(server, buf, Response);
    if(SvrRet == OARPC_SERVER_ERROR_OK)
    {
      TsRet = transport->Send(transport->UserData, Response, time_out);
      if(OARPC_TRANSPORT_ERROR_OK != TsRet)
        assert("transport error case not implemented yet!" == NULL);

      if ( time_out >= 0 )
      {
        time_out  -= (int)(GetTickCount() - StartTime);
        if( time_out <= 0 )
          return OARPC_TRANSPORT_ERROR_TIMEOUT;
      }

      TsRet = transport->Recv(transport->UserData, buf, &NewConnection, time_out);
    }

    oaRPCFreeBuf(Response);
  }

  return(TsRet);
}

static oaRPCServerErrorType 
Dispatch_GetNextCommand(oaRPCBuf *recv_buf,
                        oaInt offset,
                        oaRPCBuf *send_buf,
                        const oaRPCFunctionTable *func_table,
                        oaBool *exit_loop)
{
  oaInt Offset = offset;
  oaCommand Command;
  oaCommandType Ret;

  assert(func_table);

  oaInitCommand(&Command);

  assert(func_table->GetNextCommand);
  Ret = func_table->GetNextCommand(func_table->UserData, &Command);

  Command.Type = Ret;

  SerializeGetNextCommandResponse(&Command, send_buf);

  if(Ret == OA_CMD_EXIT)
    *exit_loop = OA_TRUE;

  return(OARPC_SERVER_ERROR_OK);
}

static oaRPCServerErrorType 
Dispatch_GetNextOption(oaRPCBuf *recv_buf,
                       oaInt offset,
                       oaRPCBuf *send_buf,
                       const oaRPCFunctionTable *func_table,
                       oaBool *exit_loop)
{
  oaInt Offset = offset;
  oaNamedOption *Option;

  assert(func_table);

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  Option = NULL;
  if(func_table->GetNextOption)
    Option = func_table->GetNextOption(func_table->UserData);

  if(Option == NULL)
  {
    oaRPCSerializeInt(send_buf, 0);
  }
  else
  {
    oaRPCSerializeInt(send_buf, Option->DataType);
    oaRPCSerializeString(send_buf, Option->Name);
    oaRPCSerializeValue(send_buf, Option->DataType, Option->Value);
  }

  return(OARPC_SERVER_ERROR_OK);
}

static oaRPCServerErrorType 
Dispatch_AddOption(oaRPCBuf *recv_buf,
                   oaInt offset,
                   oaRPCBuf *send_buf,
                   const oaRPCFunctionTable *func_table,
                   oaBool *exit_loop)
{
  oaInt Offset = offset;
  oaNamedOption Option;
  oaOptionDataType TmpType;

  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  assert(func_table);

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");
  oaInitOption(&Option);

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_INT_PARAM(recv_buf, Option.DataType);
    SHIFT_STRING_PARAM(recv_buf, Option.Name);
    SHIFT_VALUE_PARAM(recv_buf, TmpType, Option.Value);
    assert(TmpType == Option.DataType);
    SHIFT_VALUE_PARAM(recv_buf, TmpType, Option.MinValue);
    assert(TmpType == Option.DataType);
    SHIFT_VALUE_PARAM(recv_buf, TmpType, Option.MaxValue);
    assert(TmpType == Option.DataType);
    SHIFT_INT_PARAM(recv_buf, Option.NumSteps);
    SHIFT_STRING_PARAM(recv_buf, Option.Dependency.ParentName);
    SHIFT_INT_PARAM(recv_buf, Option.Dependency.ComparisonOp);
    SHIFT_INT_PARAM(recv_buf, Option.Dependency.ComparisonValType);
    SHIFT_VALUE_PARAM(recv_buf, TmpType, Option.Dependency.ComparisonVal);
    assert(TmpType == Option.Dependency.ComparisonValType);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->AddOption)
    func_table->AddOption(func_table->UserData, &Option);

  return(Ret);
}

static oaRPCServerErrorType
Dispatch_AddOptionValue(oaRPCBuf *recv_buf,
                        oaInt offset,
                        oaRPCBuf *send_buf,
                        const oaRPCFunctionTable *func_table,
                        oaBool *exit_loop)
{
  oaInt Offset = offset;
  const oaChar *Name;
  oaInt Type;
  oaValue Value;
  oaOptionDataType TmpType;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_STRING_PARAM(recv_buf, Name);
    SHIFT_INT_PARAM(recv_buf, Type);
    SHIFT_VALUE_PARAM(recv_buf, TmpType, Value);
    assert(Type == TmpType);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->AddOptionValue)
  {
    func_table->AddOptionValue(func_table->UserData, 
      Name, 
      Type, 
      &Value);
  }

  return(Ret);
}

static oaRPCServerErrorType
Dispatch_AddBenchmark(oaRPCBuf *recv_buf,
                      oaInt offset,
                      oaRPCBuf *send_buf,
                      const oaRPCFunctionTable *func_table,
                      oaBool *exit_loop)
{
  oaInt Offset = offset;
  const oaChar *Benchmark;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_STRING_PARAM(recv_buf, Benchmark);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->AddBenchmark)
    func_table->AddBenchmark(func_table->UserData, Benchmark);

  return(Ret);
}

static oaRPCServerErrorType 
Dispatch_SendSignal(oaRPCBuf *recv_buf,
                    oaInt offset,
                    oaRPCBuf *send_buf,
                    const oaRPCFunctionTable *func_table,
                    oaBool *exit_loop)
{
  oaInt Offset = offset;
  oaBool result;
  oaInt Signal;
  void *Param = NULL;
  oaMessage Message;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_INT_PARAM(recv_buf, Signal);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  switch(Signal)
  {
  case OA_SIGNAL_ERROR:
    SHIFT_INT_PARAM(recv_buf, Message.Error);
    SHIFT_STRING_PARAM(recv_buf, Message.Message);
    Param = &Message;
    break;

  case OA_SIGNAL_SYSTEM_REBOOT:
    break;

  default:
    Ret = OARPC_SERVER_ERROR_BADREQUEST;
    assert("Unknown signal!" == NULL);
  };

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->SendSignal)
  {
    result = func_table->SendSignal(func_table->UserData, 
      (oaSignalType)Signal, 
      Param);
    oaRPCSerializeBool(send_buf, result);
  }

  return(Ret);
}

static oaRPCServerErrorType
Dispatch_StartBenchmark(oaRPCBuf *recv_buf,
                        oaInt offset,
                        oaRPCBuf *send_buf,
                        const oaRPCFunctionTable *func_table,
                        oaBool *exit_loop)
{
  oaInt Offset = offset;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  if(func_table->StartBenchmark)
    func_table->StartBenchmark(func_table->UserData);

  return(OARPC_SERVER_ERROR_OK);
}

static oaRPCServerErrorType 
Dispatch_EndBenchmark(oaRPCBuf *recv_buf,
                      oaInt offset,
                      oaRPCBuf *send_buf,
                      const oaRPCFunctionTable *func_table,
                      oaBool *exit_loop)
{
  oaInt Offset = offset;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  if(func_table->EndBenchmark)
    func_table->EndBenchmark(func_table->UserData);

  return(OARPC_SERVER_ERROR_OK);
}

static oaRPCServerErrorType
Dispatch_DisplayFrame(oaRPCBuf *recv_buf,
                      oaInt offset,
                      oaRPCBuf *send_buf,
                      const oaRPCFunctionTable *func_table,
                      oaBool *exit_loop)
{
  oaInt Offset = offset;
  oaFloat T;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  assert(func_table);

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_FLOAT_PARAM(recv_buf, T);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->DisplayFrame)
    func_table->DisplayFrame(func_table->UserData, T);

  return(Ret);
}

static oaRPCServerErrorType
Dispatch_AddResultValue(oaRPCBuf *recv_buf,
                        oaInt offset,
                        oaRPCBuf *send_buf,
                        const oaRPCFunctionTable *func_table,
                        oaBool *exit_loop)
{
  oaInt Offset = offset;
  const oaChar *Name;
  oaInt ValueType;
  oaValue Value;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  assert(func_table);

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;

    SHIFT_STRING_PARAM(recv_buf, Name);
    SHIFT_INT_PARAM(recv_buf, ValueType);
    SHIFT_VALUE_PARAM(recv_buf, ValueType, Value);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->AddResultValue)
  {
    func_table->AddResultValue(func_table->UserData, 
      Name,
      (oaOptionDataType)ValueType, 
      &Value );
  }

  return(Ret);
}

static oaRPCServerErrorType
Dispatch_AddFrameValue(oaRPCBuf *recv_buf,
                       oaInt offset,
                       oaRPCBuf *send_buf,
                       const oaRPCFunctionTable *func_table,
                       oaBool *exit_loop)
{
  oaInt Offset = offset;
  const oaChar *Name;
  oaInt ValueType;
  oaValue Value;
  oaRPCServerErrorType Ret = OARPC_SERVER_ERROR_OK;

  assert(func_table);
  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");

  do 
  {
    Ret = OARPC_SERVER_ERROR_BADREQUEST;
    SHIFT_STRING_PARAM(recv_buf, Name);
    SHIFT_INT_PARAM(recv_buf, ValueType);
    SHIFT_VALUE_PARAM(recv_buf, ValueType, Value);

    Ret = OARPC_SERVER_ERROR_OK;
  } while(0);

  if(Ret == OARPC_SERVER_ERROR_OK && func_table->AddFrameValue)
  {
    func_table->AddFrameValue(func_table->UserData, 
      Name,
      (oaOptionDataType)ValueType, 
      &Value);
  }

  return(Ret);
}

oaBool SerializeGetNextCommandResponse(const oaCommand *command, 
                                       oaRPCBuf *send_buf)
{
  assert(command);
  assert(send_buf);

  SERIALIZE_RESPONSE_HEADER(OARPC_ERROR_NONE, "");
  oaRPCSerializeInt(send_buf, command->Type);

  if(command->Type == OA_CMD_RUN_BENCHMARK)
    oaRPCSerializeString(send_buf, command->BenchmarkName);
  else  
    oaRPCSerializeString(send_buf, NULL);

  return(OA_TRUE);
}

oaRPCServerErrorType oaRPCDispatch(oaRPCFuncType func_id, 
                                   oaRPCBuf *recv_buf,
                                   oaInt offset,
                                   oaRPCBuf *send_buf,
                                   const oaRPCFunctionTable *func_table,
                                   oaBool *exit_loop)
{
#define DISPATCH_CASE(command_enum, command_name) \
  case OARPC_FUNC_##command_enum: \
    Ret = Dispatch_##command_name (recv_buf, offset, send_buf, func_table, \
      exit_loop); \
    break;

  oaRPCServerErrorType Ret;

  switch(func_id)
  {
    DISPATCH_CASE(GET_NEXT_COMMAND, GetNextCommand);
    DISPATCH_CASE(GET_NEXT_OPTION,  GetNextOption);
    DISPATCH_CASE(ADD_OPTION,       AddOption);
    DISPATCH_CASE(ADD_OPTION_VALUE, AddOptionValue);
    DISPATCH_CASE(ADD_BENCHMARK,    AddBenchmark);
    DISPATCH_CASE(SEND_SIGNAL,      SendSignal);
    DISPATCH_CASE(START_BENCHMARK,  StartBenchmark);
    DISPATCH_CASE(END_BENCHMARK,    EndBenchmark);
    DISPATCH_CASE(DISPLAY_FRAME,    DisplayFrame);
    DISPATCH_CASE(ADD_RESULT_VALUE, AddResultValue);
    DISPATCH_CASE(ADD_FRAME_VALUE,  AddFrameValue);

  case OARPC_FUNC_INVALID:
    OARPC_WARNING("Invalid function id.");
    Ret = OARPC_SERVER_ERROR_UNKNOWNFUNCTION;
    break;

  default:
    Ret = OARPC_SERVER_ERROR_UNKNOWNFUNCTION;
    OARPC_WARNING("Unknown function id.");
  }

  return(Ret);
}

oaBool oaRPCServerNegotiate(oaRPCServer* server, 
                            const oaRPCBuf *request, 
                            oaRPCBuf *response)
{
  unsigned char Endian;
  
  oaRPCServerErrorType Ret;

  oaRPCSize Offset;
  const unsigned int EndianTest = 1; 
  int SystemEndian = (*(char *)&EndianTest == 1);

  assert(sizeof(unsigned long) == 4);

  if(OARPC_BUF_SIZE(request) < 57)
  {
    ERROR_MSG("oaRPC negotiation failed.  Request size is too small.");
    return(OARPC_SERVER_ERROR_BADREQUEST);
  }

  assert(MagicLen == 16); 

  if(memcmp((const void *)OARPC_GET_BUF_CONST(request, 0), 
    (const void *)Magic, 
    MagicLen) != 0)
  {
    ERROR_MSG("oaRPC negotiation failed.  Wrong magic.");
    return(OARPC_SERVER_ERROR_BADREQUEST);
  }

  Endian = *(const unsigned char *)OARPC_GET_BUF_CONST(request, 16);

  if(Endian != SystemEndian)
  {
    ERROR_MSG("System endian doesn't match client's endian.");
    return(OARPC_SERVER_ERROR_ENDIAN);
  }

  do 
  {
    Offset = 17;
    Ret = OARPC_SERVER_ERROR_BADREQUEST;
    SHIFT_INT_PARAM(request, server->Versions.ClientRPCVersionMajor);
    SHIFT_INT_PARAM(request, server->Versions.ClientRPCVersionMinor);
    SHIFT_INT_PARAM(request, server->Versions.AppOAVersionMajor);
    SHIFT_INT_PARAM(request, server->Versions.AppOAVersionMinor);
    SHIFT_INT_PARAM(request, server->Versions.AppOACustom);
    SHIFT_INT_PARAM(request, server->Versions.AppOABuild);
    SHIFT_INT_PARAM(request, server->Versions.ClientOAVersionMajor);
    SHIFT_INT_PARAM(request, server->Versions.ClientOAVersionMinor);
    SHIFT_INT_PARAM(request, server->Versions.ClientOACustom);
    SHIFT_INT_PARAM(request, server->Versions.ClientOABuild);
    Ret = OARPC_SERVER_ERROR_OK;

    if(request, server->Versions.ClientRPCVersionMajor != RPCVersionMajor)
    {
      oaRPCSerializeInt(response, OARPC_ERROR_NEGOTIATION_FAILED);
      oaRPCSerializeString(response, 
        "Negotiation failed. RPC major versions don't match.");
      Ret = OARPC_SERVER_ERROR_BADVERSION;
      break;
    }

    oaRPCClearBuf(response);

    oaRPCSerializeInt(response, OARPC_ERROR_NONE);
    oaRPCSerializeString(response, "");
    oaRPCSerializeInt(response, OA_VERSION_MAJOR);
    oaRPCSerializeInt(response, OA_VERSION_MINOR);
    oaRPCSerializeInt(response, OA_VERSION_CUSTOM);
    oaRPCSerializeInt(response, OA_VERSION_BUILD);
  } while(0);

  return(Ret);
}

