/*******************************************************************************
 * NVIDIA Corporation 
 * Software License Agreement - OpenAutomate SDK 
 * 
 * IMPORTANT - READ BEFORE COPYING, INSTALLING OR USING
 * Do not use or load the OpenAutomate SDK and any associated materials
 * provided by NVIDIA on NVIDIA’s website (collectively, the "Software")
 * until You have carefully read the following terms and conditions. By
 * loading or using the Software, You agree to fully comply with the terms
 * and conditions of this Software License Agreement ("Agreement") by and
 * between NVIDIA Corporation, a Delaware corporation with its principal
 * place of business at 2701 San Tomas Expressway, Santa Clara, California
 * 95050 U.S.A. ("NVIDIA"), and You. If You do not wish to so agree, do not
 * install or use the Software. 
 * 
 * For the purposes of this Agreement: 
 * 
 * "Licensee," "You" and/or "Your" shall mean, collectively and
 * individually, Original Equipment Manufacturers, Independent Hardware
 * Vendors, Independent Software Vendors, and End-Users of the Software
 * pursuant to the terms and conditions of this Agreement.   
 * 
 * "Derivative Works" shall mean derivatives of the Software created by You
 * or a third party on Your behalf, which term shall include:  (a) for
 * copyrightable or copyrighted material, any translation, abridgement,
 * revision or other form in which an existing work may be recast,
 * transformed or adapted; (b) for work protected by topography or mask
 * right, any translation, abridgement, revision or other form in which an
 * existing work may be recast, transformed or adapted; (c) for patentable
 * or patented material, any Improvement; and (d) for material protected by
 * trade secret, any new material derived from or employing such existing
 * trade secret.
 * 
 * "Excluded License" is any license that requires as a condition of use,
 * modification and/or distribution of software subject to the Excluded
 * License, that such software or other software distributed and/or
 * combined with such software be (i) disclosed or distributed in source
 * code form, (ii) licensed for the purpose of making derivative works, or
 * (iii) redistributable at no charge.
 * 
 * SECTION 1 - GRANT OF LICENSE.
 * NVIDIA agrees to provide the Software and any associated materials
 * pursuant to the terms and conditions of this Agreement.  Subject to the
 * terms of this Agreement, NVIDIA grants to You a nonexclusive,
 * transferable, worldwide, revocable, limited, royalty-free, fully paid-up
 * license under NVIDIA’s copyrights to 
 * 
 * (a) install, deploy, use, have used execute, reproduce, display,
 * perform, run, modify the source code of the Software, or to prepare and
 * have prepared Derivative Works thereof the Software for Your own
 * internal development, testing and maintenance purposes to incorporate
 * the Software or Derivative Works thereof, in part or whole, into Your
 * software applications; 
 * 
 * (b)	 to transfer, distribute and sublicense the Software (in its
 * unmodified form as delivered to You by NVIDIA pursuant to this
 * Agreement) in any medium or technology for Your sublicensees to
 * incorporate the Software or Derivative Works thereof, in part or whole,
 * into their respective software applications; and
 * 
 * (c) to transfer, distribute and sublicense Derivative Works (in object
 * code only) of the Software (i)_as incorporated in Your application
 * software in any medium or technology; and (ii) certified as OpenAutomate
 * Compatible Software.
 * 
 * You may exercise your license rights pursuant to Subsection 1(b) and (c)
 * above pursuant to the terms and conditions of any form of end-user
 * software license agreement of Your choice, including but not limited to
 * an Excluded License.
 * 
 * In the event NVIDIA certifies Your application software, incorporating
 * the Derivative Works (in object code only) of the Software, as
 * OpenAutomate compatible ("OpenAutomate Compatible Software"), NVIDIA
 * grants You a nonexclusive, worldwide, revocable, paid-up license to use
 * the name and trademark to "OpenAutomate Compatible" solely for the
 * purposes of identifying and/or marketing Your application software as
 * OpenAutomate Compatible Software; provided that Licensee fully complies
 * with the following:	
 * 
 * (x) Licensee agrees that it is strictly prohibited from using the name
 * and trademark of "OpenAutomate Compatible" if Your application software
 * is not OpenAutomate Compatible Software;
 * 
 * (y) if NVIDIA objects to Your improper use of the "OpenAutomate
 * Compatible" name and trademark, You will take all reasonable steps
 * necessary to resolve NVIDIA’s objections. NVIDIA may reasonably monitor
 * the quality of Your application software bearing the "OpenAutomate
 * Compatible" name or trademark pursuant to this Agreement; and
 * 
 * (z) any goodwill attached to NVIDIA’s trademarks, service marks, or
 * trade names belong to NVIDIA and this Agreement does not grant You any
 * right to use them.
 * 
 * If You are not the final manufacturer or vendor of a computer system or
 * software program incorporating the Software, or if Your Contractors (as
 * defined below), affiliates or subsidiaries need to exercise any, some or
 * all of the license grant described above herein to the Software on Your
 * behalf, then You may transfer a copy of the Software, (and related
 * end-user documentation) to such recipient for use in accordance with the
 * terms of this Agreement, provided such recipient agrees to be fully
 * bound by the terms hereof. Except as expressly permitted in this
 * Agreement, Unless otherwise authorized in the Agreement, You shall not
 * otherwise assign, sublicense, lease, or in any other way transfer or
 * disclose Software to any third party. Unless otherwise authorized in the
 * Agreement, You shall not reverse- compile, disassemble,
 * reverse-engineer, or in any manner attempt to derive the source code of
 * the Software from the object code portions of the Software. 
 * 
 * Except as expressly stated in this Agreement, no license or right is
 * granted to You directly or by implication, inducement, estoppel or
 * otherwise. NVIDIA shall have the right to inspect or have an independent
 * auditor inspect Your relevant records to verify Your compliance with the
 * terms and conditions of this Agreement. 
 * 
 * SECTION 2 - CONFIDENTIALITY.
 * If applicable, any exchange of Confidential Information (as defined in
 * the NDA) shall be made pursuant to the terms and conditions of a
 * separately signed Non-Disclosure Agreement ("NDA") by and between NVIDIA
 * and You. For the sake of clarity, You agree that the Software is
 * Confidential Information of NVIDIA.
 * 
 * If You wish to have a third party consultant or subcontractor
 * ("Contractor") perform work on Your behalf which involves access to or
 * use of Software, You shall obtain a written confidentiality agreement
 * from the Contractor which contains terms and obligations with respect to
 * access to or use of Software no less restrictive than those set forth in
 * this Agreement and excluding any distribution or sublicense rights, and
 * use for any other purpose than permitted in this Agreement. Otherwise,
 * You shall not disclose the terms or existence of this Agreement or use
 * NVIDIA's name in any publications, advertisements, or other
 * announcements without NVIDIA's prior written consent.  Unless otherwise
 * provided in this Agreement, You do not have any rights to use any NVIDIA
 * trademarks or logos.
 * 
 * SECTION 3 - OWNERSHIP OF SOFTWARE AND INTELLECTUAL PROPERTY RIGHTS.
 * All rights, title and interest to all copies of the Software remain with
 * NVIDIA, subsidiaries, licensors, or its suppliers. The Software is
 * copyrighted and protected by the laws of the United States and other
 * countries, and international treaty provisions. You may not remove any
 * copyright notices from the Software. NVIDIA may make changes to the
 * Software, or to items referenced therein, at any time and without
 * notice, but is not obligated to support or update the Software. Except
 * as otherwise expressly provided, NVIDIA grants no express or implied
 * right under any NVIDIA patents, copyrights, trademarks, or other
 * intellectual property rights. 
 * 
 * All rights, title and interest in the Derivative Works of the Software
 * remain with You subject to the underlying license from NVIDIA to the
 * Software.  In Your sole discretion, You may grant NVIDIA, upon NVIDIA’s
 * request for such a license described herein, an irrevocable, perpetual,
 * nonexclusive, worldwide, royalty-free paid-up license to make, have
 * made, use, have used, sell, license, distribute, sublicense or otherwise
 * transfer Derivative Works created by You that add functionality or
 * improvement to the Software.  
 * 
 * You has no obligation to give NVIDIA any suggestions, comments or other
 * feedback ("Feedback") relating to the Software.  However, NVIDIA may use
 * and include any Feedback that You voluntarily provide to improve the
 * Software or other related NVIDIA technologies.  Accordingly, if You
 * provide Feedback, You agree NVIDIA and its licensees may freely use,
 * reproduce, license, distribute, and otherwise commercialize the Feedback
 * in the Software or other related technologies without the payment of any
 * royalties or fees.  
 * 
 * You may transfer the Software only if the recipient agrees to be fully
 * bound by these terms and conditions of this Agreement. 
 * 
 * SECTION 4 - NO WARRANTIES. 
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY
 * OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT,
 * OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA does not warrant or assume
 * responsibility for the accuracy or completeness of any information,
 * text, graphics, links or other items contained within the Software.
 * NVIDIA does not represent that errors or other defects will be
 * identified or corrected.
 * 
 * SECTION 5 - LIMITATION OF LIABILITY.
 * EXCEPT WITH RESPECT TO THE MISUSE OF THE OTHER PARTY’S INTELLECTUAL
 * PROPERTY OR DISCLOSURE OF THE OTHER PARTY’S CONFIDENTIAL INFORMATION IN
 * BREACH OF THIS AGREEMENT, IN NO EVENT SHALL NVIDIA, SUBSIDIARIES,
 * LICENSORS, OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION,  INDIRECT, LOST PROFITS, CONSEQUENTIAL,
 * BUSINESS INTERRUPTION OR LOST INFORMATION) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THE SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS PROHIBIT EXCLUSION OR
 * LIMITATION OF LIABILITY FOR IMPLIED WARRANTIES OR CONSEQUENTIAL OR
 * INCIDENTAL DAMAGES, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU. YOU
 * MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM JURISDICTION TO
 * JURISDICTION.  NOTWITHSTANDING THE FOREGOING, NVIDIA’S AGGREGATE
 * LIABILITY ARISING OUT OF THIS AGREEMENT SHALL NOT EXCEED ONE HUNDRED
 * UNITED STATES DOLLARS (USD$100).
 * 
 * SECTION 6 - TERM.
 * This Agreement and the licenses granted hereunder shall be effective as
 * of the date You download the applicable Software ("Effective Date") and
 * continue for a period of one (1) year ("Initial Term") respectively,
 * unless terminated earlier in accordance with the "Termination" provision
 * of this Agreement.  Unless either party notifies the other party of its
 * intent to terminate this Agreement at least three (3) months prior to
 * the end of the Initial Term or the applicable renewal period, this
 * Agreement will be automatically renewed for one (1) year renewal periods
 * thereafter, unless terminated in accordance with the "Termination"
 * provision of this Agreement.  
 * 
 * SECTION 7 - TERMINATION.
 * NVIDIA may terminate this Agreement at any time if You violate its
 * terms. Upon termination, You will immediately destroy the Software or
 * return all copies of the Software to NVIDIA, and certify to NVIDIA in
 * writing that such actions have been completed.  Upon termination or
 * expiration of this Agreement the license grants to Licensee shall
 * terminate, except that sublicenses rightfully granted by Licensee under
 * this Agreement in connection with Section 1(b) and (c) of this Agreement
 * provided by Licensee prior to the termination or expiration of this
 * Agreement shall survive in accordance with their respective form of
 * license terms and conditions.
 * 
 * SECTION 8 - MISCELLANEOUS.
 * 
 * SECTION 8.1 - SURVIVAL.
 * Those provisions in this Agreement, which by their nature need to
 * survive the termination or expiration of this Agreement, shall survive
 * termination or expiration of the Agreement, including but not limited to
 * Sections 2, 3, 4, 5, 7, and 8.
 * 
 * SECTION 8.2 - APPLICABLE LAWS.
 * Claims arising under this Agreement shall be governed by the laws of
 * Delaware, excluding its principles of conflict of laws and the United
 * Nations Convention on Contracts for the Sale of Goods. The state and/or
 * federal courts residing in Santa Clara County, California shall have
 * exclusive jurisdiction over any dispute or claim arising out of this
 * Agreement. You may not export the Software in violation of applicable
 * export laws and regulations. 
 * 
 * SECTION 8.3 - AMENDMENT.
 * The Agreement shall not be modified except by a written agreement that
 * names this Agreement and any provision to be modified, is dated
 * subsequent to the Effective Date, and is signed by duly authorized
 * representatives of both parties.
 * 
 * SECTION 8.4 - NO WAIVER.
 * No failure or delay on the part of either party in the exercise of any
 * right, power or remedy under this Agreement or under law, or to insist
 * upon or enforce performance by the other party of any of the provisions
 * of this Agreement or under law, shall operate as a waiver thereof, nor
 * shall any single or partial exercise of any right, power or remedy
 * preclude other or further exercise thereof, or the exercise of any other
 * right, power or remedy; rather the provision, right, or remedy shall be
 * and remain in full force and effect.
 * 
 * SECTION 8.5 - NO ASSIGNMENT. 
 * This Agreement and Licensee’s rights and obligations herein, may not be
 * assigned, subcontracted, delegated, or otherwise transferred by Licensee
 * without NVIDIA’s prior written consent, and any attempted assignment,
 * subcontract, delegation, or transfer in violation of the foregoing will
 * be null and void.  The terms of this Agreement shall be binding upon
 * Licensee’s assignees.
 * 
 * SECTION 8.6 - GOVERNMENT RESTRICTED RIGHTS. 
 * The parties acknowledge that the Software is subject to U.S. export
 * control laws and regulations.   The parties agree to comply with all
 * applicable international and national laws that apply to the Software,
 * including the U.S. Export Administration Regulations, as well as
 * end-user, end-use and destination restrictions issued by U.S. and other
 * governments.
 * 
 * The Software has been developed entirely at private expense and is
 * commercial computer software provided with RESTRICTED RIGHTS. Use,
 * duplication or disclosure of the Software by the U.S. Government or a
 * U.S. Government subcontractor is subject to the restrictions set forth
 * in the Agreement under which the Software was obtained pursuant to DFARS
 * 227.7202-3(a) or as set forth in subparagraphs (c)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR
 * 52.227-19, as applicable. Contractor/manufacturer is NVIDIA, 2701 San
 * Tomas Expressway, Santa Clara, CA 95050. Use of the Software by the
 * Government constitutes acknowledgment of NVIDIA's proprietary rights
 * therein. 
 * 
 * SECTION 8.7 - INDEPENDENT CONTRACTORS.
 * Licensee’s relationship to NVIDIA is that of an independent contractor,
 * and neither party is an agent or partner of the other.  Licensee will
 * not have, and will not represent to any third party that it has, any
 * authority to act on behalf of NVIDIA.
 * 
 * SECTION 8.8 - SEVERABILITY.
 * If for any reason a court of competent jurisdiction finds any provision
 * of this Agreement, or portion thereof, to be unenforceable, that
 * provision of the Agreement will be enforced to the maximum extent
 * permissible so as to affect the intent of the parties, and the remainder
 * of this Agreement will continue in full force and effect. This Agreement
 * has been negotiated by the parties and their respective counsel and will
 * be interpreted fairly in accordance with its terms and without any
 * strict construction in favor of or against either party.
 * 
 * SECTION 8.9 - ENTIRE AGREEMENT.  
 * This Agreement and NDA constitute the entire agreement between the
 * parties with respect to the subject matter contemplated herein, and
 * merges all prior and contemporaneous communications.
 * 
 ******************************************************************************/



#include "OpenAutomateUtil.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#if OA_PLATFORM == OA_WIN32 || OA_PLATFORM == OA_CYGWIN
#  include <windows.h>
#  define DIR_SEPARATOR "\\"
# else
#  include <stat.h>
#  define DIR_SEPARATOR "/"
#endif

#if OA_PLATFORM == WIN32
#define STRTOK strtok_s
#else
#define STRTOK strtok_r
#endif

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_LINE_LEN (16 * 1024)
#define MAX_PATH_LEN 1024

#define PRINT_STR(str) \
   fprintf(stderr, "%s, %d: %s = \"%s\"\n", __FILE__, __LINE__, #str, str);

#define PRINT_INT(val) \
   fprintf(stderr, "%s, %d: %s = %d\n", __FILE__, __LINE__, #val, val);


/*******************************************************************************
* Prototypes
******************************************************************************/


static oaBool CheckMagic(const char *str);
static oaBool ParseNameValue(const char *str,  char *name, char *value);
static void StripWhitespace(char *str);
static oaBool SetAppBuildInfoParam(oauAppBuildInfo *info, 
                                   const char *name,
                                   const char *value);
static const char *GetEnvDir(void);
static const char *GetHomeDir(void);
static const char *GetSystemRootDir(void);
static void ConstructAppBuildRelPath(const oauAppBuildId *app_id, 
                                     char *path,
                                     int path_size);
static oaBool MakePath(const char *path);
static oaBool MakeDirectory(const char *filename);
static oaBool IsDirectory(const char *filename);
static oaBool FileExists(const char* filename);
static const char *BaseName(const char *filename);
static const char *DirName(const char *filename, char *ret);
static void *OpenDir(const char *dirname);
static oaBool ReadDir(void *dir, char *entry_name, int entry_size);
static oaBool CloseDir(void *dir);

typedef oaBool (*RecurseDirCallbackType)(const char *filename, 
                                         const char *full_path,
                                         int level,
                                         void *user_data);
static oaBool RecurseDir(const char *dirname, 
                         RecurseDirCallbackType func,
                         int level,
                         void *user_data);
static oaBool oauWriteRegistrationValue(HKEY Key,
                                        const char *reg_path,
                                        const oauAppBuildInfo *app_info);
static oaBool oauWriteRegistryString(HKEY hKey, LPCTSTR lpKey, LPCTSTR lpValue, const char* lpData);
static oaBool MakeKey(const char *path, HKEY* Key);
static oaBool DeleteReg(const char* path);
static oaBool RegExists(const char* path);
static oaBool RemoveRegistry(const char *basedir, const oauAppBuildId *app_id);


/*******************************************************************************
* Globals
******************************************************************************/

static char MagicBase[] = "OAREG ";
static char EnvDir[MAX_PATH_LEN] = "";
static char HomeDir[MAX_PATH_LEN] = "";
static char SystemRootDir[MAX_PATH_LEN] = "";
static oaInt RegFormatMajorVersion = 1;
static oaInt RegFormatMinorVersion = 0;

static char AppRegSubPath[] = 
  DIR_SEPARATOR "OpenAutomate" DIR_SEPARATOR "RegisteredApps";

static char HomeAppRegSubPath[] = 
  DIR_SEPARATOR ".OpenAutomate" DIR_SEPARATOR "RegisteredApps";

static char SystemRegistryRoot[] =
  "HKEY_LOCAL_MACHINE\\SOFTWARE\\OpenAutomate\\RegisteredApps";

static char UserRegistryRoot[] =
  "HKEY_CURRENT_USER\\SOFTWARE\\OpenAutomate\\RegisteredApps";

/*******************************************************************************
* Public Functions
******************************************************************************/

oauAppBuildId *oauAllocAppBuildId(void)
{
  oauAppBuildId *AppId = (oauAppBuildId *)malloc(sizeof(oauAppBuildId));
  memset(AppId, 0, sizeof(oauAppBuildId));
  return(AppId);
}

#define COND_FREE(ptr) \
    if(ptr) \
      free(ptr);

void oauFreeAppBuildId(oauAppBuildId *app_id)
{
  assert(app_id);

  COND_FREE(app_id->DevName)
  COND_FREE(app_id->AppName)
  COND_FREE(app_id->AppBuildName)

  free(app_id);
}

oauAppBuildInfo *oauAllocAppBuildInfo(void)
{
  oauAppBuildInfo *AppInfo = (oauAppBuildInfo *)malloc(sizeof(oauAppBuildInfo));
  memset(AppInfo, 0, sizeof(oauAppBuildInfo));
  return(AppInfo);
}

void oauFreeAppBuildInfo(oauAppBuildInfo *app_info)
{
  assert(app_info);

  COND_FREE(app_info->InstallRootPath)
  COND_FREE(app_info->EntryExe)
  COND_FREE(app_info->InstallDateTime)
  COND_FREE(app_info->Region)

  free(app_info);
}

oauAppBuildRegEntry *oauAllocAppBuildRegEntry(void)
{
  oauAppBuildRegEntry *AppEntry = 
   (oauAppBuildRegEntry *)malloc(sizeof(oauAppBuildRegEntry));
  memset(AppEntry, 0, sizeof(oauAppBuildRegEntry));

  AppEntry->Id = oauAllocAppBuildId();
  AppEntry->Info = oauAllocAppBuildInfo();

  return(AppEntry);
}

void oauFreeAppBuildRegEntry(oauAppBuildRegEntry *app_entry)
{
  assert(app_entry);

  oauFreeAppBuildId(app_entry->Id);
  oauFreeAppBuildInfo(app_entry->Info);

  free(app_entry);
}

static void ConstructFullRegPath(const char *basedir, 
                                 const oauAppBuildId *app_id, 
                                 char *ret)
{
  char RelPath[MAX_PATH_LEN];

  ConstructAppBuildRelPath(app_id, RelPath, MAX_PATH_LEN);

  strncpy(ret, basedir, MAX_PATH_LEN);
  strncat(ret, DIR_SEPARATOR, MAX_PATH_LEN);
  strncat(ret, RelPath, MAX_PATH_LEN);
}

static oaBool WriteRegFile(const char *basedir,
                           const oauAppBuildId *app_id,
                           const oauAppBuildInfo *app_info)
{
  char Path[MAX_PATH_LEN];
  char Dir[MAX_PATH_LEN];

  if(!basedir)
    return(OA_FALSE);

  ConstructFullRegPath(basedir, app_id, Path);

  DirName(Path, Dir);

  if(Dir[0] && !MakePath(Dir))
    return(OA_FALSE);

  return(oauWriteRegistrationFile(Path, app_info));
}

oaBool oauRegisterAppBuild(oauAppBuildRegMethod method,
                           const oauAppBuildId *app_id,
                           const oauAppBuildInfo *app_info)
{
  switch(method)
  {
    case OAU_REGISTER_FILE_ENV:
      return(WriteRegFile(GetEnvDir(), app_id, app_info));

    case OAU_REGISTER_FILE_HOME:
      return(WriteRegFile(GetHomeDir(), app_id, app_info));

    case OAU_REGISTER_FILE_SYSTEM:
      return(WriteRegFile(GetSystemRootDir(), app_id, app_info));

    case OAU_REGISTER_REGISTRY_USER:
      return(oauWriteRegistryKey(UserRegistryRoot, app_id, app_info));

    case OAU_REGISTER_REGISTRY_SYSTEM:
      return(oauWriteRegistryKey(SystemRegistryRoot, app_id, app_info));

    default:

      assert("Shouldn't be here!" == NULL);
  }; 

  return(OA_FALSE);
}

oaBool RemoveRegFile(const char *basedir, const oauAppBuildId *app_id)
{
  char Path[MAX_PATH_LEN];
  
  ConstructFullRegPath(basedir, app_id, Path);

  if(!FileExists(Path))
    return(OA_TRUE);

  return(remove(Path) ? OA_FALSE : OA_TRUE);
}

oaBool RemoveRegistry(const char *basedir, const oauAppBuildId *app_id)
{
  char Path[MAX_PATH_LEN];

  ConstructFullRegPath(basedir, app_id, Path);

  if (!RegExists(Path))
    return(OA_TRUE);

  return(DeleteReg(Path) ? OA_TRUE : OA_FALSE);

}

oaBool RegExists(const char* path)
{
  HKEY temp;
  char Path[MAX_PATH_LEN];
  char *Last;
  char *Token;
  LONG error;
  wchar_t *SubKey = (wchar_t *)malloc( MAX_PATH_LEN * sizeof(wchar_t));

  if(!SubKey)
    return (OA_FALSE);

  assert (Path);

  strncpy(Path,path,sizeof(Path));

  Token = STRTOK(Path,DIR_SEPARATOR,&Last);

  if (mbstowcs(SubKey,Last,MAX_PATH_LEN) == (size_t)(-1))
    return (OA_FALSE);

  if (Token[0])
  {
    if (strcmp(Token,"HKEY_CURRENT_USER") == 0)
    {
      error = RegOpenKeyEx(HKEY_CURRENT_USER,SubKey,0,KEY_WRITE,&temp);
    }
    else if(strcmp(Token,"HKEY_LOCAL_MACHINE") == 0)
    {
      error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,SubKey,0,KEY_WRITE,&temp);
    }
  }

  free(SubKey);
  
  return ((error == ERROR_SUCCESS) ? OA_TRUE:OA_FALSE);
}

oaBool DeleteReg(const char* path)
{
  char Path[MAX_PATH_LEN];
  char *Last;
  char *Token;
  LONG error;
  wchar_t *SubKey = (wchar_t *)malloc( MAX_PATH_LEN * sizeof(wchar_t));

  if(!SubKey)
    return (OA_FALSE);
  
  assert (Path);
  
  strncpy(Path,path,sizeof(Path));

  Token = STRTOK(Path,DIR_SEPARATOR,&Last);

  if (mbstowcs(SubKey,Last,MAX_PATH_LEN) == (size_t)(-1))
    return (OA_FALSE);

  if (Token[0])
  {
    if (strcmp(Token,"HKEY_CURRENT_USER") == 0)
    {
      error = RegDeleteKey(HKEY_CURRENT_USER,SubKey);
    }
    else if(strcmp(Token,"HKEY_LOCAL_MACHINE") == 0)
    {
      error = RegDeleteKey(HKEY_LOCAL_MACHINE,SubKey);
    }
  }

  free(SubKey);
  return ((error == ERROR_SUCCESS) ? OA_TRUE:OA_FALSE);

}

oaBool oauUnregisterAppBuild(oauAppBuildRegMethod method,
                             const oauAppBuildId *app_id)
{
  switch(method)
  {
    case OAU_REGISTER_FILE_ENV :
      return(RemoveRegFile(GetHomeDir(), app_id));

    case OAU_REGISTER_FILE_HOME :
      return(RemoveRegFile(GetHomeDir(), app_id));

    case OAU_REGISTER_FILE_SYSTEM :
      return(RemoveRegFile(GetSystemRootDir(), app_id));

    case OAU_REGISTER_REGISTRY_USER:
      return(RemoveRegistry(UserRegistryRoot, app_id));

    case OAU_REGISTER_REGISTRY_SYSTEM :
      return(RemoveRegistry(SystemRegistryRoot, app_id));

    default:

      assert("Shouldn't be here!" == NULL);
  }; 
  return(OA_FALSE);
}


static oaBool DoubleAppBuildListBuf(oauAppBuildList *list)
{
  oauAppBuildRegEntry **NewBuf;
  oaInt NewSize;
  
  assert(list);

  NewSize = 2 * list->BufSize * sizeof(oauAppBuildRegEntry *);
  NewBuf = (oauAppBuildRegEntry **)realloc(list->AppBuilds, NewSize);

  if(!NewBuf)
    return(OA_FALSE);

  list->AppBuilds = NewBuf;
  list->BufSize = NewSize;

  return(OA_TRUE);
}

static oauAppBuildRegEntry *FindAppBuildInList(const char *dev_name,
                                               const char *app_name,
                                               const char *build_name,
                                               oauAppBuildList *list)
{
  int i;

  assert(dev_name);
  assert(app_name);
  assert(build_name);

  for(i=0; i < list->NumAppBuilds; ++i)
  {
    if(strcmp(list->AppBuilds[i]->Id->DevName, dev_name))
      continue;
      
    if(strcmp(list->AppBuilds[i]->Id->AppName, app_name))
      continue;
      
    if(strcmp(list->AppBuilds[i]->Id->AppBuildName, build_name))
      continue;

    return(list->AppBuilds[i]);
  }

  return(NULL);
}

static void AddAppBuildToList(const char *dev_name,
                              const char *app_name,
                              const char *build_name,
                              oauAppBuildInfo *info,
                              oauAppBuildRegMethod method,
                              oauAppBuildList *list)
{
  oauAppBuildRegEntry *AppBuild;

  assert(list->NumAppBuilds <= list->BufSize);

  if(list->NumAppBuilds == list->BufSize)
  {
    oaBool Ret = DoubleAppBuildListBuf(list);
    assert(Ret);
  }

  AppBuild = FindAppBuildInList(dev_name, app_name, build_name, list);

  if(!AppBuild)
  {
    AppBuild = oauAllocAppBuildRegEntry();

    AppBuild->Id->DevName = strdup(dev_name);
    AppBuild->Id->AppName = strdup(app_name);
    AppBuild->Id->AppBuildName = strdup(build_name);
  
    free(AppBuild->Info);
    AppBuild->Info = info;

    list->AppBuilds[list->NumAppBuilds++] = AppBuild;
  }

  AppBuild->Methods = (oauAppBuildRegMethod)(AppBuild->Methods | method);
}

typedef enum 
{
  SEARCH_LEVEL_DEV   = 1,
  SEARCH_LEVEL_APP   = 2,
  SEARCH_LEVEL_BUILD = 3
} SearchRecurseLevel;

typedef struct
{
  char DevName[MAX_PATH_LEN];
  char AppName[MAX_PATH_LEN];
  oauAppBuildList *AppBuildList;
  oauAppBuildRegMethod Method;
} SearchRecurseData;

oaBool SearchRecurseCallback(const char *filename, 
                             const char *full_path,
                             int level,
                             void *user_data)
{
  SearchRecurseData *Data = (SearchRecurseData *)user_data;


  assert(Data);

  switch(level)
  {
    case SEARCH_LEVEL_DEV:
      if(IsDirectory(full_path))
      {
        strncpy(Data->DevName, filename, MAX_PATH_LEN);
        return(OA_TRUE);
      }
      break;

    case SEARCH_LEVEL_APP:
      if(IsDirectory(full_path))
      {
        strncpy(Data->AppName, filename, MAX_PATH_LEN);
        return(OA_TRUE);
      }
      break;

    case SEARCH_LEVEL_BUILD:
      if(!IsDirectory(full_path))
      {
        oauAppBuildInfo *Info = oauAllocAppBuildInfo();

        if(!oauReadRegistrationFile(full_path, Info))
        {
          oauFreeAppBuildInfo(Info);
          return(OA_FALSE);
        }

        AddAppBuildToList(Data->DevName,
                          Data->AppName,
                          filename,
                          Info,
                          Data->Method,
                          Data->AppBuildList);


        
        return(OA_FALSE);
      }
      break;
  }

  return(OA_FALSE);
}

static void SearchRegisteredAppBuilds(const char *dir,
                                      oauAppBuildList *list,
                                      oauAppBuildRegMethod method)
{
  //char Filename[MAX_PATH_LEN];
  //char FullPath[MAX_PATH_LEN];

  SearchRecurseData Data;

  if(!dir || !IsDirectory(dir))
    return;

  memset(&Data, 0, sizeof(Data));
  Data.AppBuildList = list;
  Data.Method = method;

  RecurseDir(dir, SearchRecurseCallback, 1, &Data);

}

static oauAppBuildList *AllocAppBuildList(void)
{
  oauAppBuildList *Ret;

  const oaInt InitialBufSize = 64;
  const oaInt BufBytes =  InitialBufSize  * sizeof(oauAppBuildRegEntry);

  Ret = (oauAppBuildList *)malloc(sizeof(oauAppBuildList));
  memset(Ret, 0, sizeof(oauAppBuildList));

  Ret->AppBuilds = (oauAppBuildRegEntry **)malloc(BufBytes);
  memset(Ret->AppBuilds, 0, BufBytes);

  Ret->NumAppBuilds = 0;
  Ret->BufSize = InitialBufSize;
 
  return(Ret);
}

oauAppBuildList *oauGetAllRegisteredAppBuilds(void)
{
  //char Child[MAX_PATH_LEN];
  oauAppBuildList *Ret = AllocAppBuildList();

  SearchRegisteredAppBuilds(GetEnvDir(), Ret, OAU_REGISTER_FILE_ENV);
  SearchRegisteredAppBuilds(GetHomeDir(), Ret, OAU_REGISTER_FILE_HOME);
  SearchRegisteredAppBuilds(GetSystemRootDir(), Ret, OAU_REGISTER_FILE_SYSTEM);

  return(Ret);
}

void oauFreeAppBuildList(oauAppBuildList *appbuilds)
{
  oaInt i;

  assert(appbuilds);
  assert(appbuilds->AppBuilds);

  for(i=0; i < appbuilds->NumAppBuilds; ++i)
  {
    assert(appbuilds->AppBuilds[i]);
    free(appbuilds->AppBuilds[i]);
  }

  free(appbuilds->AppBuilds);
  free(appbuilds);
}

oaBool oauWriteRegistrationFile(const char *filename,
                                const oauAppBuildInfo *app_info)
{
  FILE *OutFile;

  assert(filename);
  assert(app_info);

  OutFile = fopen(filename, "wb");
  if(!OutFile)
  {
    fprintf(stderr, "ERROR: Couldn't open '%s' for write.\n", filename);
    return(OA_FALSE);
  }

  fprintf(OutFile, 
          "OAREG %d.%d\n\n", 
          RegFormatMajorVersion, 
          RegFormatMinorVersion);

  fprintf(OutFile, "INSTALL_ROOT_PATH : %s\n", app_info->InstallRootPath);
  fprintf(OutFile, "ENTRY_EXE         : %s\n", app_info->EntryExe);
  fprintf(OutFile, "INSTALL_DATETIME  : %s\n", app_info->InstallDateTime);
  fprintf(OutFile, "REGION            : %s\n", app_info->Region);


  if(fclose(OutFile))
    return(OA_FALSE);

  return(OA_TRUE);
 
}

oaBool oauReadRegistrationFile(const char *filename,
                               oauAppBuildInfo *app_info)
{
  FILE *InFile;
  char LineBuf[MAX_LINE_LEN];
  char Name[MAX_LINE_LEN];
  char Value[MAX_LINE_LEN];

  assert(filename);
  assert(app_info);

  InFile = fopen(filename, "rb");

  if(!InFile)
  {
    fprintf(stderr, "Couldn't open '%s' for read.", filename);
    return(OA_FALSE);
  }

  if(!fgets(LineBuf, sizeof(LineBuf), InFile))
    goto error;

  if(!CheckMagic(LineBuf))
    goto error;

  while(fgets(LineBuf, sizeof(LineBuf), InFile))
  {
    StripWhitespace(LineBuf);

    /* Ignore lines only containing whitespace */
    if(!LineBuf[0])
      continue;

    if(!ParseNameValue(LineBuf, Name, Value))
      goto error;

    SetAppBuildInfoParam(app_info, Name, Value);
  }

  fclose(InFile);
  return(OA_TRUE);

  error:
    fclose(InFile);
    return(OA_FALSE);
}

#if OA_PLATFORM == OA_WIN32 || OA_PLATFORM == OA_CYGWIN

oaBool oauWriteRegistryKey(const char *key_path,
                           const oauAppBuildId *app_id,
                           const oauAppBuildInfo *app_info)
{
  char Path[MAX_PATH_LEN];
  HKEY Key;
  
  if(!key_path)
    return (OA_FALSE);

  ConstructFullRegPath(key_path,app_id,Path);

  if (!MakeKey(Path, &Key))
    return (OA_FALSE);

  return (oauWriteRegistrationValue(Key, Path, app_info));
}

oaBool MakeKey(const char *path, HKEY* Key)
{
  char Path[MAX_PATH_LEN];
  char *Last;
  char *Token;

  DWORD dwDisp;
  HKEY temp;
  wchar_t *CurPath = (wchar_t *)malloc( MAX_PATH_LEN * sizeof( wchar_t ));
  LONG error;

  if (!CurPath)
    return (OA_FALSE);

  assert(path);
  
  strncpy(Path, path, sizeof(Path));

  Token = STRTOK(Path,DIR_SEPARATOR,&Last);

  if ( mbstowcs( CurPath, Last, MAX_PATH_LEN) == (size_t)(-1) )
    return (OA_FALSE);

  if(Token[0])
  {
    if (strcmp(Token,"HKEY_CURRENT_USER") == 0)
    {
      *Key = HKEY_CURRENT_USER;
    }
    else if(strcmp(Token,"HKEY_LOCAL_MACHINE") == 0)
    {
      *Key = HKEY_LOCAL_MACHINE;
    }

    error = RegOpenKeyEx((HKEY)*Key,CurPath,0,KEY_WRITE,&temp);

    if (error == ERROR_SUCCESS)
    {
      free(CurPath);
      return (OA_TRUE);
    }

    if (RegCreateKeyEx((HKEY)*Key,CurPath,0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&temp,&dwDisp) == ERROR_SUCCESS)
    {
      free(CurPath);
      return (OA_TRUE);
    }
  }

  free(CurPath);
  return (OA_FALSE);
}

oaBool oauWriteRegistrationValue(HKEY Key,
                                 const char *reg_path,
                                 const oauAppBuildInfo *app_info)
{
  char *Token;
  char *Last;
  wchar_t *Subkey = (wchar_t *)malloc( MAX_PATH_LEN * sizeof( wchar_t ));

  if (!Subkey)
    return (OA_FALSE);

  assert(reg_path);
  assert(app_info);

  Token = STRTOK((char*)reg_path,DIR_SEPARATOR,&Last);

  if ( mbstowcs( Subkey, Last, MAX_PATH_LEN) == (size_t)(-1) )
    return (OA_FALSE);

  if (!oauWriteRegistryString(Key,Subkey,TEXT("INSTALL_ROOT_PATH"),app_info->InstallRootPath))
    return (OA_FALSE);
  if (!oauWriteRegistryString(Key,Subkey,TEXT("ENTRY_EXE"),app_info->EntryExe))
    return (OA_FALSE);
  if (!oauWriteRegistryString(Key,Subkey,TEXT("INSTALL_DATETIME"),app_info->InstallDateTime))
    return (OA_FALSE);
  if (!oauWriteRegistryString(Key,Subkey,TEXT("REGION"),app_info->Region))
    return (OA_FALSE);

  return (OA_TRUE);
}

oaBool oauWriteRegistryString(HKEY hKey, LPCTSTR lpKey, LPCTSTR lpValue, const char* lpData)
{
  HKEY key;
  //DWORD dwDisp;
  wchar_t *wlpData = (wchar_t *)malloc( MAX_PATH_LEN * sizeof( wchar_t ));

  if (!wlpData)
    return (OA_FALSE);
  if(mbstowcs( wlpData, lpData, MAX_PATH_LEN) == (size_t)(-1))
    return (OA_FALSE);

  if (RegOpenKeyEx((HKEY)hKey,lpKey,0,KEY_ALL_ACCESS,&key) != ERROR_SUCCESS)
  {
    free(wlpData);
    return (OA_FALSE);
  }
  
  if (RegSetValueEx(key,lpValue,0,REG_SZ,(LPBYTE)wlpData,(lstrlen(wlpData)+1)*sizeof(LPCTSTR))
    != ERROR_SUCCESS)
  {
    free(wlpData);
    return (OA_FALSE);
  }

  RegCloseKey(key);
  
  free(wlpData);
  return (OA_TRUE);
}


oaBool oauReadRegistryKey(const char *key_path,
                          const oauAppBuildId *app_id,
                          oauAppBuildInfo *app_info)
{
  assert("NOT IMPLEMENTED YET!!!" == NULL);

  return(OA_FALSE);
}

#else

oaBool oauWriteRegistryKey(const char *key_path,
                           const oauAppBuildInfo *app_info)
{
  return(OA_FALSE);
}


oaBool oauReadRegistryKey(const char *key_path,
                          oauAppBuildInfo *app_info)
{
  return(OA_FALSE);
}

#endif

/*******************************************************************************
* Private Functions
******************************************************************************/

static void ConstructAppBuildRelPath(const oauAppBuildId *app_id, 
                                     char *path,
                                     int path_size)
{
  assert(app_id);
  assert(app_id->DevName);
  assert(app_id->AppName);
  assert(app_id->AppBuildName);
  assert(path);

  strncpy(path, app_id->DevName, path_size);
  strncat(path, DIR_SEPARATOR, path_size);
  strncat(path, app_id->AppName, path_size);
  strncat(path, DIR_SEPARATOR, path_size);
  strncat(path, app_id->AppBuildName, path_size);
}

static char **GetAppBuildInfoMember(oauAppBuildInfo *info, const char *name)
{
  //oauAppBuildInfo Info;

# define CHECK_NAME(member_name, member_var) \
    if(!strcmp(#member_name, name)) \
      return(&info->member_var);

  CHECK_NAME(INSTALL_ROOT_PATH, InstallRootPath)
  CHECK_NAME(ENTRY_EXE, EntryExe)
  CHECK_NAME(INSTALL_DATETIME, InstallDateTime)
  CHECK_NAME(REGION, Region)

  return(NULL);
}

oaBool SetAppBuildInfoParam(oauAppBuildInfo *info, 
                            const char *name,
                            const char *value)
{
  char **MemberVal;
  if((MemberVal = GetAppBuildInfoMember(info, name)) == NULL)
  {
    fprintf(stderr, "Warning: Unknown name '%s'\n", name);
    return(OA_FALSE);
  }

  if(*MemberVal)
    free(*MemberVal);

  *MemberVal = strdup(value);
  return(OA_TRUE);
}

static oaInt ParseTillChar(const char *str, char c, oaBool end_ok)
{
  oaInt Offset = 0;
  
  while(1)
  {
    if(!*str)
    {
      if(end_ok)
        return(Offset);
      else
        return(-1);
    }

    if(*str == c)
      return(Offset);

    Offset++;
    str++;
  }
 
  return(-1);
}

static oaBool IsWhitespace(char c)
{
  return((c == ' ' ||
          c == '\t' ||
          c == '\r' ||
          c == '\n') ? OA_TRUE : OA_FALSE);
}

void StripWhitespace(char *str)
{
  oaInt Start = 0;
  oaInt End = 0;
  oaInt i = 0;
  oaInt StrLen;

  assert(str);

  StrLen = (oaInt)strlen(str);

  if(StrLen == 0)
   return;

  while(str[Start] && IsWhitespace(str[Start]))
    Start++;

  End = StrLen - 1;

  if(End <= Start)
  {
    *str = 0;
    return;
  }

  while(IsWhitespace(str[End]))
    End--;

  assert(End >= Start); 

  for(; Start <= End; Start++, i++)
    str[i] = str[Start];

  str[i] = 0;
}

oaBool ParseNameValue(const char *str,  char *name, char *value)
{
  char Buf[MAX_LINE_LEN];
  char *Str = Buf;
  oaInt Offset;

  assert(str);
  assert(name);
  assert(value);

  strcpy(Str, str);
  StripWhitespace(Str);

  Offset = ParseTillChar(Str, ':', OA_FALSE);
  if(Offset == -1)
    return(OA_FALSE);

  strncpy(name, Str, Offset);
  name[Offset] = 0;
  StripWhitespace(name);

  strcpy(value, Str + Offset + 1);
  StripWhitespace(value);

  return(OA_TRUE);
}

oaBool CheckMagic(const char *str)
{
  char Buf[MAX_LINE_LEN];
  char *Str = Buf;
  oaInt MagicBaseLen, StrLen;
  oaInt Offset;
  oaInt Major, Minor;

  assert(str);
  strcpy(Str, str);

  StripWhitespace(Str);


  MagicBaseLen = (oaInt)strlen(MagicBase);
  StrLen = (oaInt)strlen(Str);

  if(StrLen < MagicBaseLen)
    return(OA_FALSE);

  if(strncmp(str, MagicBase, MagicBaseLen))
    return(OA_FALSE);

  Str += MagicBaseLen;
  StrLen -= MagicBaseLen;

  /* Remaining string should at least have the 3 chars for the version number 
     (major.minor) */
  if(StrLen < 3)
    return(OA_FALSE);

  Offset = ParseTillChar(Str, '.', OA_FALSE);
  if(Offset == -1)
    return(OA_FALSE);
 
  Str[Offset] = 0;
  Major = atoi(Str);
  if(Major != RegFormatMajorVersion)
    return(OA_FALSE);

  Str += Offset + 1;
  Minor = atoi(Str);

  return(OA_TRUE);
}

oaBool MakePath(const char *path)
{
//#if 0
  char Path[MAX_PATH_LEN];
  char CurPath[MAX_PATH_LEN] = "";
  char *Last;
  char *Token;

  assert(path);

  strncpy(Path, path, sizeof(Path));

  Token = STRTOK(Path,DIR_SEPARATOR,&Last);
  
  while(Token)
  {
    if(Token[0])
    {
      strncat(CurPath, Token, sizeof(CurPath));
      strncat(CurPath, DIR_SEPARATOR, sizeof(CurPath));

      if(!IsDirectory(CurPath))
      {
        if(FileExists(CurPath))
        {
          return(OA_FALSE);
        }
        else
          if(!MakeDirectory(CurPath))
            return(OA_FALSE);
      }
    }

    Token = STRTOK(Last,DIR_SEPARATOR,&Last);
  }
//#endif
  return(OA_TRUE);
}

const char *BaseName(const char *filename) 
{
  const char *Ret;
  char Separator[] = DIR_SEPARATOR;

  for(Ret=filename; Ret[0] && Ret[1]; Ret++);

  while(Ret > filename && Ret[-1] != Separator[0])
   Ret--;

  return(Ret);
}


const char *DirName(const char *filename, char *ret)
{
  const char *Base = BaseName(filename);
  int FilenameLen = (int)strlen(filename);
  int BaseLen = (int)strlen(Base);
  int Delta = FilenameLen - BaseLen;

  if(Delta == 0)
    ret[0] = 0;
  else
  {
    strncpy(ret, filename, Delta);
    ret[Delta] = 0;
  }

  return(ret);
}

const char *GetEnvDir(void)
{
  if(!HomeDir[0])
  {
    char *EnvVar = getenv("OPENAUTOMATE_DIR");

    if(!(EnvVar))
      return(NULL);

    strncpy(EnvDir, EnvVar, MAX_PATH_LEN);
    strncat(EnvDir, AppRegSubPath, MAX_PATH_LEN);
  }

  return(EnvDir);
}

oaBool RecurseDir(const char *dirname, 
                  RecurseDirCallbackType func,
                  int level,
                  void *user_data)
{
  char FullPath[MAX_PATH_LEN];
  char Filename[MAX_PATH_LEN];
  void *Dir;

  if((Dir = OpenDir(dirname)) == NULL)
    return(OA_FALSE);

  while(ReadDir(Dir, Filename, sizeof(Filename)))
  {
    strncpy(FullPath, dirname, sizeof(FullPath));
    strncat(FullPath, DIR_SEPARATOR, sizeof(FullPath));
    strncat(FullPath, Filename, sizeof(FullPath));

    if(IsDirectory(FullPath))
    {
      if(!strcmp(Filename, ".") || !strcmp(Filename, ".."))
        continue;

      if(!func(Filename, FullPath, level, user_data))
        goto early_out;

      RecurseDir(FullPath, func, level + 1, user_data);
    }
    else
      func(Filename, FullPath, level, user_data);
  }

early_out:

  CloseDir(Dir);
  return(OA_TRUE);
}

#if OA_PLATFORM == OA_WIN32 || OA_PLATFORM == OA_CYGWIN

const char *GetHomeDir(void)
{
  if(!HomeDir[0])
  {
    char *HomeDriveEnv = getenv("HOMEDRIVE");
    char *HomePathEnv = getenv("HOMEPATH");

    if(!(HomeDriveEnv && HomePathEnv))
      return(NULL);

    strncpy(HomeDir, HomeDriveEnv, MAX_PATH_LEN);
    strncat(HomeDir, DIR_SEPARATOR, MAX_PATH_LEN);
    strncat(HomeDir, HomePathEnv, MAX_PATH_LEN);
    strncat(HomeDir, HomeAppRegSubPath, MAX_PATH_LEN);
  }

  return(HomeDir);
}

const char *GetSystemRootDir(void)
{
  if(!SystemRootDir[0])
  {
    char *SystemRootEnv = getenv("SystemRoot");

    if(!SystemRootEnv )
      return(NULL);

    strncpy(SystemRootDir, SystemRootEnv, MAX_PATH_LEN);
    strncat(SystemRootDir, AppRegSubPath, MAX_PATH_LEN);
  }

  return(SystemRootDir);
}

oaBool MakeDirectory(const char *filename)
{
 return(CreateDirectoryA(filename, NULL) ? OA_TRUE : OA_FALSE);
 }

oaBool IsDirectory(const char *filename)
{
  DWORD Attributes = GetFileAttributesA(filename);

  if(Attributes == 0xFFFFFFFF)
    return(OA_FALSE);

  if(Attributes & FILE_ATTRIBUTE_DIRECTORY)
    return(OA_TRUE);

   return(OA_FALSE);
}


oaBool FileExists(const char* filename)
{
  HANDLE File = CreateFileA(filename, 
                            GENERIC_READ, 
                            FILE_SHARE_READ, 
                            NULL, 
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL,  
                            0);


  if(File == INVALID_HANDLE_VALUE)
    return(OA_FALSE);

  CloseHandle(File);
  return(OA_TRUE);
}

typedef struct 
{
  HANDLE DirHandle;
  WIN32_FIND_DATAA FindData;
  char LastEntry[MAX_PATH_LEN];
} DirType;

void *OpenDir(const char *dirname)
{
  DirType *Ret;
  int Len;
  char SearchSpec[MAX_PATH_LEN];

  assert(dirname);
  if(!IsDirectory(dirname))
    return(NULL);

  Len = (int)strlen(dirname);
  if(Len == 0)
    return(NULL);

  Ret = (DirType *)malloc(sizeof(DirType));
  memset(Ret, 0, sizeof(DirType));

  strncpy(SearchSpec, dirname, sizeof(SearchSpec));
  if(!(SearchSpec[Len-1] == '/' || SearchSpec[Len-1] == '\\'))
    strncat(SearchSpec, "\\", sizeof(SearchSpec));

  strncat(SearchSpec, "*.*", sizeof(SearchSpec));

  Ret->DirHandle = FindFirstFileA(SearchSpec, &Ret->FindData);

  if(Ret->DirHandle == INVALID_HANDLE_VALUE)
  {
    free(Ret);
    return(NULL);
  }

  strncpy(Ret->LastEntry, Ret->FindData.cFileName, MAX_PATH_LEN);

  return((void *)Ret);
}

oaBool ReadDir(void *dir, char *entry_name, int entry_size)
{
  DirType *Dir = (DirType *)dir;

  if(!Dir->LastEntry[0])
    return(OA_FALSE);

  strncpy(entry_name, Dir->LastEntry, entry_size);

  if(FindNextFileA(Dir->DirHandle, &Dir->FindData))
    strncpy(Dir->LastEntry, Dir->FindData.cFileName, MAX_PATH_LEN);
  else
  {
    FindClose(Dir->DirHandle);
    Dir->LastEntry[0] = 0;
    Dir->DirHandle = INVALID_HANDLE_VALUE;
  }

  return(OA_TRUE);
}

oaBool CloseDir(void *dir)
{
  DirType *Dir = (DirType *)dir;

  assert(Dir);

  if(Dir->DirHandle)
    FindClose(Dir->DirHandle);

  free(Dir);

  return(OA_TRUE);
}

#else

#  error "Only Win32/Cygwin are currently supported."

oaBool MakeDirectory(const char *filename)
{
 return(!mkdir(filename, S_IWOTH | S_IWGRP | S_IWUSR | 
                         S_IROTH | S_IRGRP | S_IRUSR));
 }

oaBool IsDirectory(const char *filename)
{
  struct stat Stat;
  int Ret = stat(filename, &Stat);

  if(Ret)
    return(false);

  if(S_ISDIR(Stat.st_mode))
    return(true);

  return(false);
}

oaBool FileExists(const char* filename)
{
  struct stat status;
  return (stat(filename,&status) == 0); 
}

#endif




#ifdef __cplusplus
}
#endif
